/*
Wazuh API REST

The Wazuh API is an open-source RESTful API that allows for interaction with the Wazuh manager from a web browser, command line tools like cURL or any script or program that can make web requests. The Wazuh WUI relies on this heavily and Wazuhâ€™s goal is to accommodate complete remote management of the Wazuh infrastructure via the Wazuh WUI. Use the Wazuh API to easily perform everyday actions like adding an agent, restarting the manager(s) or agent(s) or looking up syscheck details.  # Authentication  Wazuh API endpoints require authentication to be used. Therefore, all calls must include a JSON Web Token. JWT is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. Perform a call with `basicAuth` to `POST /security/user/authenticate` and obtain a JWT token to run any endpoint.  JWT tokens have a default duration of 900 seconds. To change this value, you must perform a call with a valid JWT token to `PUT /security/config`. After this change, you will need to get a new JWT token as all previously issued tokens are revoked when any change is performed on security configuration.  Login with USER and PASSWORD:  `curl -u <USER>:<PASSWORD> -k -X POST \"https://<HOST_IP>:55000/security/user/authenticate\"` ```json {     \"data\": {         \"token\": \"<YOUR_JWT_TOKEN>\"     },     \"error\": 0 } ``` Use the token from the previous response to perform any endpoint request:  `curl -k -X <METHOD> \"https://<HOST_IP>:55000/<ENDPOINT>\" -H  \"Authorization: Bearer <YOUR_JWT_TOKEN>\"`  Change the token base duration:  `curl -k -X PUT \"https://<HOST_IP>:55000/security/config\" -H \"Authorization: Bearer <YOUR_JWT_TOKEN>\" -d '{\"auth_token_exp_timeout\": <NEW_EXPIRE_TIME_IN_SECONDS>}'`  <SecurityDefinitions /> 

API version: 4.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"os"
)


// RulesAPIService RulesAPI service
type RulesAPIService service

type ApiApiControllersRuleControllerDeleteFileRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	filename string
	pretty *bool
	waitForComplete *bool
	relativeDirname *string
}

// Show results in human-readable format
func (r ApiApiControllersRuleControllerDeleteFileRequest) Pretty(pretty bool) ApiApiControllersRuleControllerDeleteFileRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersRuleControllerDeleteFileRequest) WaitForComplete(waitForComplete bool) ApiApiControllersRuleControllerDeleteFileRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// Filter by relative directory name
func (r ApiApiControllersRuleControllerDeleteFileRequest) RelativeDirname(relativeDirname string) ApiApiControllersRuleControllerDeleteFileRequest {
	r.relativeDirname = &relativeDirname
	return r
}

func (r ApiApiControllersRuleControllerDeleteFileRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersRuleControllerDeleteFileExecute(r)
}

/*
ApiControllersRuleControllerDeleteFile Delete rules file

Delete a specified rule file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param filename Filename (rule or decoder) to download/upload/edit file.
 @return ApiApiControllersRuleControllerDeleteFileRequest
*/
func (a *RulesAPIService) ApiControllersRuleControllerDeleteFile(ctx context.Context, filename string) ApiApiControllersRuleControllerDeleteFileRequest {
	return ApiApiControllersRuleControllerDeleteFileRequest{
		ApiService: a,
		ctx: ctx,
		filename: filename,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *RulesAPIService) ApiControllersRuleControllerDeleteFileExecute(r ApiApiControllersRuleControllerDeleteFileRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.ApiControllersRuleControllerDeleteFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rules/files/{filename}"
	localVarPath = strings.Replace(localVarPath, "{"+"filename"+"}", url.PathEscape(parameterValueToString(r.filename, "filename")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.relativeDirname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relative_dirname", r.relativeDirname, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersRuleControllerGetFileRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	filename string
	pretty *bool
	waitForComplete *bool
	raw *bool
	relativeDirname *string
}

// Show results in human-readable format
func (r ApiApiControllersRuleControllerGetFileRequest) Pretty(pretty bool) ApiApiControllersRuleControllerGetFileRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersRuleControllerGetFileRequest) WaitForComplete(waitForComplete bool) ApiApiControllersRuleControllerGetFileRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// Format response in plain text
func (r ApiApiControllersRuleControllerGetFileRequest) Raw(raw bool) ApiApiControllersRuleControllerGetFileRequest {
	r.raw = &raw
	return r
}

// Filter by relative directory name
func (r ApiApiControllersRuleControllerGetFileRequest) RelativeDirname(relativeDirname string) ApiApiControllersRuleControllerGetFileRequest {
	r.relativeDirname = &relativeDirname
	return r
}

func (r ApiApiControllersRuleControllerGetFileRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersRuleControllerGetFileExecute(r)
}

/*
ApiControllersRuleControllerGetFile Get rules file content

Get the content of a specified rule in the ruleset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param filename Filename (rule or decoder) to download/upload/edit file.
 @return ApiApiControllersRuleControllerGetFileRequest
*/
func (a *RulesAPIService) ApiControllersRuleControllerGetFile(ctx context.Context, filename string) ApiApiControllersRuleControllerGetFileRequest {
	return ApiApiControllersRuleControllerGetFileRequest{
		ApiService: a,
		ctx: ctx,
		filename: filename,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *RulesAPIService) ApiControllersRuleControllerGetFileExecute(r ApiApiControllersRuleControllerGetFileRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.ApiControllersRuleControllerGetFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rules/files/{filename}"
	localVarPath = strings.Replace(localVarPath, "{"+"filename"+"}", url.PathEscape(parameterValueToString(r.filename, "filename")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.raw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "raw", r.raw, "form", "")
	}
	if r.relativeDirname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relative_dirname", r.relativeDirname, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersRuleControllerGetRulesRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	ruleIds *[]int32
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	select_ *[]string
	sort *string
	search *string
	q *string
	status *string
	group *string
	level *string
	filename *[]string
	relativeDirname *string
	pciDss *string
	gdpr *string
	gpg13 *string
	hipaa *string
	nist80053 *string
	tsc *string
	mitre *string
	distinct *bool
}

// List of rule IDs
func (r ApiApiControllersRuleControllerGetRulesRequest) RuleIds(ruleIds []int32) ApiApiControllersRuleControllerGetRulesRequest {
	r.ruleIds = &ruleIds
	return r
}

// Show results in human-readable format
func (r ApiApiControllersRuleControllerGetRulesRequest) Pretty(pretty bool) ApiApiControllersRuleControllerGetRulesRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersRuleControllerGetRulesRequest) WaitForComplete(waitForComplete bool) ApiApiControllersRuleControllerGetRulesRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersRuleControllerGetRulesRequest) Offset(offset int32) ApiApiControllersRuleControllerGetRulesRequest {
	r.offset = &offset
	return r
}

// Maximum number of elements to return. Although up to 100.000 can be specified, it is recommended not to exceed 500 elements. Responses may be slower the more this number is exceeded. 
func (r ApiApiControllersRuleControllerGetRulesRequest) Limit(limit int32) ApiApiControllersRuleControllerGetRulesRequest {
	r.limit = &limit
	return r
}

// Select which fields to return (separated by comma). Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersRuleControllerGetRulesRequest) Select_(select_ []string) ApiApiControllersRuleControllerGetRulesRequest {
	r.select_ = &select_
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersRuleControllerGetRulesRequest) Sort(sort string) ApiApiControllersRuleControllerGetRulesRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersRuleControllerGetRulesRequest) Search(search string) ApiApiControllersRuleControllerGetRulesRequest {
	r.search = &search
	return r
}

// Query to filter results by. For example q&#x3D;&amp;quot;status&#x3D;active&amp;quot;
func (r ApiApiControllersRuleControllerGetRulesRequest) Q(q string) ApiApiControllersRuleControllerGetRulesRequest {
	r.q = &q
	return r
}

// Filter by list status. Use commas to enter multiple statuses
func (r ApiApiControllersRuleControllerGetRulesRequest) Status(status string) ApiApiControllersRuleControllerGetRulesRequest {
	r.status = &status
	return r
}

// Filter by rule group
func (r ApiApiControllersRuleControllerGetRulesRequest) Group(group string) ApiApiControllersRuleControllerGetRulesRequest {
	r.group = &group
	return r
}

// Filter by rule level. Can be a single level (4) or an interval (2-4)
func (r ApiApiControllersRuleControllerGetRulesRequest) Level(level string) ApiApiControllersRuleControllerGetRulesRequest {
	r.level = &level
	return r
}

// Filter by filename
func (r ApiApiControllersRuleControllerGetRulesRequest) Filename(filename []string) ApiApiControllersRuleControllerGetRulesRequest {
	r.filename = &filename
	return r
}

// Filter by relative directory name
func (r ApiApiControllersRuleControllerGetRulesRequest) RelativeDirname(relativeDirname string) ApiApiControllersRuleControllerGetRulesRequest {
	r.relativeDirname = &relativeDirname
	return r
}

// Filter by PCI_DSS requirement name
func (r ApiApiControllersRuleControllerGetRulesRequest) PciDss(pciDss string) ApiApiControllersRuleControllerGetRulesRequest {
	r.pciDss = &pciDss
	return r
}

// Filter by GDPR requirement
func (r ApiApiControllersRuleControllerGetRulesRequest) Gdpr(gdpr string) ApiApiControllersRuleControllerGetRulesRequest {
	r.gdpr = &gdpr
	return r
}

// Filter by GPG13 requirement
func (r ApiApiControllersRuleControllerGetRulesRequest) Gpg13(gpg13 string) ApiApiControllersRuleControllerGetRulesRequest {
	r.gpg13 = &gpg13
	return r
}

// Filter by HIPAA requirement
func (r ApiApiControllersRuleControllerGetRulesRequest) Hipaa(hipaa string) ApiApiControllersRuleControllerGetRulesRequest {
	r.hipaa = &hipaa
	return r
}

// Filter by NIST-800-53 requirement
func (r ApiApiControllersRuleControllerGetRulesRequest) Nist80053(nist80053 string) ApiApiControllersRuleControllerGetRulesRequest {
	r.nist80053 = &nist80053
	return r
}

// Filters by TSC requirement
func (r ApiApiControllersRuleControllerGetRulesRequest) Tsc(tsc string) ApiApiControllersRuleControllerGetRulesRequest {
	r.tsc = &tsc
	return r
}

// Filters by MITRE technique ID
func (r ApiApiControllersRuleControllerGetRulesRequest) Mitre(mitre string) ApiApiControllersRuleControllerGetRulesRequest {
	r.mitre = &mitre
	return r
}

// Look for distinct values.
func (r ApiApiControllersRuleControllerGetRulesRequest) Distinct(distinct bool) ApiApiControllersRuleControllerGetRulesRequest {
	r.distinct = &distinct
	return r
}

func (r ApiApiControllersRuleControllerGetRulesRequest) Execute() (*ApiControllersRuleControllerGetRules200Response, *http.Response, error) {
	return r.ApiService.ApiControllersRuleControllerGetRulesExecute(r)
}

/*
ApiControllersRuleControllerGetRules List rules

Return a list containing information about each rule such as file where it's defined, description, rule group, status, etc

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersRuleControllerGetRulesRequest
*/
func (a *RulesAPIService) ApiControllersRuleControllerGetRules(ctx context.Context) ApiApiControllersRuleControllerGetRulesRequest {
	return ApiApiControllersRuleControllerGetRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersRuleControllerGetRules200Response
func (a *RulesAPIService) ApiControllersRuleControllerGetRulesExecute(r ApiApiControllersRuleControllerGetRulesRequest) (*ApiControllersRuleControllerGetRules200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersRuleControllerGetRules200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.ApiControllersRuleControllerGetRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ruleIds != nil {
		t := *r.ruleIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rule_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rule_ids", t, "form", "multi")
		}
	}
	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.filename != nil {
		t := *r.filename
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filename", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filename", t, "form", "multi")
		}
	}
	if r.relativeDirname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relative_dirname", r.relativeDirname, "form", "")
	}
	if r.pciDss != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pci_dss", r.pciDss, "form", "")
	}
	if r.gdpr != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gdpr", r.gdpr, "form", "")
	}
	if r.gpg13 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpg13", r.gpg13, "form", "")
	}
	if r.hipaa != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hipaa", r.hipaa, "form", "")
	}
	if r.nist80053 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nist-800-53", r.nist80053, "form", "")
	}
	if r.tsc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tsc", r.tsc, "form", "")
	}
	if r.mitre != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitre", r.mitre, "form", "")
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "form", "")
	} else {
		var defaultValue bool = false
		r.distinct = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersRuleControllerGetRulesFilesRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
	relativeDirname *string
	filename *[]string
	status *string
	q *string
	select_ *[]string
	distinct *bool
}

// Show results in human-readable format
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) Pretty(pretty bool) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) WaitForComplete(waitForComplete bool) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) Offset(offset int32) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.offset = &offset
	return r
}

// Maximum number of elements to return. Although up to 100.000 can be specified, it is recommended not to exceed 500 elements. Responses may be slower the more this number is exceeded. 
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) Limit(limit int32) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) Sort(sort string) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) Search(search string) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.search = &search
	return r
}

// Filter by relative directory name
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) RelativeDirname(relativeDirname string) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.relativeDirname = &relativeDirname
	return r
}

// Filter by filename of one or more rule or decoder files.
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) Filename(filename []string) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.filename = &filename
	return r
}

// Filter by list status. Use commas to enter multiple statuses
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) Status(status string) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.status = &status
	return r
}

// Query to filter results by. For example q&#x3D;&amp;quot;status&#x3D;active&amp;quot;
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) Q(q string) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.q = &q
	return r
}

// Select which fields to return (separated by comma). Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) Select_(select_ []string) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.select_ = &select_
	return r
}

// Look for distinct values.
func (r ApiApiControllersRuleControllerGetRulesFilesRequest) Distinct(distinct bool) ApiApiControllersRuleControllerGetRulesFilesRequest {
	r.distinct = &distinct
	return r
}

func (r ApiApiControllersRuleControllerGetRulesFilesRequest) Execute() (*ApiControllersRuleControllerGetRulesFiles200Response, *http.Response, error) {
	return r.ApiService.ApiControllersRuleControllerGetRulesFilesExecute(r)
}

/*
ApiControllersRuleControllerGetRulesFiles Get files

Return a list containing all files used to define rules and their status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersRuleControllerGetRulesFilesRequest
*/
func (a *RulesAPIService) ApiControllersRuleControllerGetRulesFiles(ctx context.Context) ApiApiControllersRuleControllerGetRulesFilesRequest {
	return ApiApiControllersRuleControllerGetRulesFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersRuleControllerGetRulesFiles200Response
func (a *RulesAPIService) ApiControllersRuleControllerGetRulesFilesExecute(r ApiApiControllersRuleControllerGetRulesFilesRequest) (*ApiControllersRuleControllerGetRulesFiles200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersRuleControllerGetRulesFiles200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.ApiControllersRuleControllerGetRulesFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rules/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.relativeDirname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relative_dirname", r.relativeDirname, "form", "")
	}
	if r.filename != nil {
		t := *r.filename
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filename", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filename", t, "form", "multi")
		}
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "form", "")
	} else {
		var defaultValue bool = false
		r.distinct = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersRuleControllerGetRulesGroupsRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
}

// Show results in human-readable format
func (r ApiApiControllersRuleControllerGetRulesGroupsRequest) Pretty(pretty bool) ApiApiControllersRuleControllerGetRulesGroupsRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersRuleControllerGetRulesGroupsRequest) WaitForComplete(waitForComplete bool) ApiApiControllersRuleControllerGetRulesGroupsRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersRuleControllerGetRulesGroupsRequest) Offset(offset int32) ApiApiControllersRuleControllerGetRulesGroupsRequest {
	r.offset = &offset
	return r
}

// Maximum number of elements to return. Although up to 100.000 can be specified, it is recommended not to exceed 500 elements. Responses may be slower the more this number is exceeded. 
func (r ApiApiControllersRuleControllerGetRulesGroupsRequest) Limit(limit int32) ApiApiControllersRuleControllerGetRulesGroupsRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersRuleControllerGetRulesGroupsRequest) Sort(sort string) ApiApiControllersRuleControllerGetRulesGroupsRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersRuleControllerGetRulesGroupsRequest) Search(search string) ApiApiControllersRuleControllerGetRulesGroupsRequest {
	r.search = &search
	return r
}

func (r ApiApiControllersRuleControllerGetRulesGroupsRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersRuleControllerGetRulesGroupsExecute(r)
}

/*
ApiControllersRuleControllerGetRulesGroups Get groups

Return a list containing all rule groups names

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersRuleControllerGetRulesGroupsRequest
*/
func (a *RulesAPIService) ApiControllersRuleControllerGetRulesGroups(ctx context.Context) ApiApiControllersRuleControllerGetRulesGroupsRequest {
	return ApiApiControllersRuleControllerGetRulesGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *RulesAPIService) ApiControllersRuleControllerGetRulesGroupsExecute(r ApiApiControllersRuleControllerGetRulesGroupsRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.ApiControllersRuleControllerGetRulesGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rules/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersRuleControllerGetRulesRequirementRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	requirement string
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
}

// Show results in human-readable format
func (r ApiApiControllersRuleControllerGetRulesRequirementRequest) Pretty(pretty bool) ApiApiControllersRuleControllerGetRulesRequirementRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersRuleControllerGetRulesRequirementRequest) WaitForComplete(waitForComplete bool) ApiApiControllersRuleControllerGetRulesRequirementRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersRuleControllerGetRulesRequirementRequest) Offset(offset int32) ApiApiControllersRuleControllerGetRulesRequirementRequest {
	r.offset = &offset
	return r
}

// Maximum number of elements to return. Although up to 100.000 can be specified, it is recommended not to exceed 500 elements. Responses may be slower the more this number is exceeded. 
func (r ApiApiControllersRuleControllerGetRulesRequirementRequest) Limit(limit int32) ApiApiControllersRuleControllerGetRulesRequirementRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersRuleControllerGetRulesRequirementRequest) Sort(sort string) ApiApiControllersRuleControllerGetRulesRequirementRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersRuleControllerGetRulesRequirementRequest) Search(search string) ApiApiControllersRuleControllerGetRulesRequirementRequest {
	r.search = &search
	return r
}

func (r ApiApiControllersRuleControllerGetRulesRequirementRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersRuleControllerGetRulesRequirementExecute(r)
}

/*
ApiControllersRuleControllerGetRulesRequirement Get requirements

Return all specified requirement names defined in the Wazuh ruleset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requirement
 @return ApiApiControllersRuleControllerGetRulesRequirementRequest
*/
func (a *RulesAPIService) ApiControllersRuleControllerGetRulesRequirement(ctx context.Context, requirement string) ApiApiControllersRuleControllerGetRulesRequirementRequest {
	return ApiApiControllersRuleControllerGetRulesRequirementRequest{
		ApiService: a,
		ctx: ctx,
		requirement: requirement,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *RulesAPIService) ApiControllersRuleControllerGetRulesRequirementExecute(r ApiApiControllersRuleControllerGetRulesRequirementRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.ApiControllersRuleControllerGetRulesRequirement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rules/requirement/{requirement}"
	localVarPath = strings.Replace(localVarPath, "{"+"requirement"+"}", url.PathEscape(parameterValueToString(r.requirement, "requirement")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersRuleControllerPutFileRequest struct {
	ctx context.Context
	ApiService *RulesAPIService
	filename string
	body *os.File
	pretty *bool
	waitForComplete *bool
	overwrite *bool
	relativeDirname *string
}

// Content of the rule to be uploaded
func (r ApiApiControllersRuleControllerPutFileRequest) Body(body *os.File) ApiApiControllersRuleControllerPutFileRequest {
	r.body = body
	return r
}

// Show results in human-readable format
func (r ApiApiControllersRuleControllerPutFileRequest) Pretty(pretty bool) ApiApiControllersRuleControllerPutFileRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersRuleControllerPutFileRequest) WaitForComplete(waitForComplete bool) ApiApiControllersRuleControllerPutFileRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// If set to false, an exception will be raised when updating contents of an already existing filename
func (r ApiApiControllersRuleControllerPutFileRequest) Overwrite(overwrite bool) ApiApiControllersRuleControllerPutFileRequest {
	r.overwrite = &overwrite
	return r
}

// Filter by relative directory name
func (r ApiApiControllersRuleControllerPutFileRequest) RelativeDirname(relativeDirname string) ApiApiControllersRuleControllerPutFileRequest {
	r.relativeDirname = &relativeDirname
	return r
}

func (r ApiApiControllersRuleControllerPutFileRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersRuleControllerPutFileExecute(r)
}

/*
ApiControllersRuleControllerPutFile Update rules file

Upload or replace a user ruleset file content

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param filename Filename (rule or decoder) to download/upload/edit file.
 @return ApiApiControllersRuleControllerPutFileRequest
*/
func (a *RulesAPIService) ApiControllersRuleControllerPutFile(ctx context.Context, filename string) ApiApiControllersRuleControllerPutFileRequest {
	return ApiApiControllersRuleControllerPutFileRequest{
		ApiService: a,
		ctx: ctx,
		filename: filename,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *RulesAPIService) ApiControllersRuleControllerPutFileExecute(r ApiApiControllersRuleControllerPutFileRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RulesAPIService.ApiControllersRuleControllerPutFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rules/files/{filename}"
	localVarPath = strings.Replace(localVarPath, "{"+"filename"+"}", url.PathEscape(parameterValueToString(r.filename, "filename")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.overwrite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "overwrite", r.overwrite, "form", "")
	} else {
		var defaultValue bool = false
		r.overwrite = &defaultValue
	}
	if r.relativeDirname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relative_dirname", r.relativeDirname, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
