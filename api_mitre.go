/*
Wazuh API REST

The Wazuh API is an open-source RESTful API that allows for interaction with the Wazuh manager from a web browser, command line tools like cURL or any script or program that can make web requests. The Wazuh WUI relies on this heavily and Wazuhâ€™s goal is to accommodate complete remote management of the Wazuh infrastructure via the Wazuh WUI. Use the Wazuh API to easily perform everyday actions like adding an agent, restarting the manager(s) or agent(s) or looking up syscheck details.  # Authentication  Wazuh API endpoints require authentication to be used. Therefore, all calls must include a JSON Web Token. JWT is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. Perform a call with `basicAuth` to `POST /security/user/authenticate` and obtain a JWT token to run any endpoint.  JWT tokens have a default duration of 900 seconds. To change this value, you must perform a call with a valid JWT token to `PUT /security/config`. After this change, you will need to get a new JWT token as all previously issued tokens are revoked when any change is performed on security configuration.  Login with USER and PASSWORD:  `curl -u <USER>:<PASSWORD> -k -X POST \"https://<HOST_IP>:55000/security/user/authenticate\"` ```json {     \"data\": {         \"token\": \"<YOUR_JWT_TOKEN>\"     },     \"error\": 0 } ``` Use the token from the previous response to perform any endpoint request:  `curl -k -X <METHOD> \"https://<HOST_IP>:55000/<ENDPOINT>\" -H  \"Authorization: Bearer <YOUR_JWT_TOKEN>\"`  Change the token base duration:  `curl -k -X PUT \"https://<HOST_IP>:55000/security/config\" -H \"Authorization: Bearer <YOUR_JWT_TOKEN>\" -d '{\"auth_token_exp_timeout\": <NEW_EXPIRE_TIME_IN_SECONDS>}'`  <SecurityDefinitions /> 

API version: 4.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// MITREAPIService MITREAPI service
type MITREAPIService service

type ApiApiControllersMitreControllerGetGroupsRequest struct {
	ctx context.Context
	ApiService *MITREAPIService
	groupIds *[]string
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
	select_ *[]string
	q *string
	distinct *bool
}

// List of MITRE&#39;s group IDs (separated by comma)
func (r ApiApiControllersMitreControllerGetGroupsRequest) GroupIds(groupIds []string) ApiApiControllersMitreControllerGetGroupsRequest {
	r.groupIds = &groupIds
	return r
}

// Show results in human-readable format
func (r ApiApiControllersMitreControllerGetGroupsRequest) Pretty(pretty bool) ApiApiControllersMitreControllerGetGroupsRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersMitreControllerGetGroupsRequest) WaitForComplete(waitForComplete bool) ApiApiControllersMitreControllerGetGroupsRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersMitreControllerGetGroupsRequest) Offset(offset int32) ApiApiControllersMitreControllerGetGroupsRequest {
	r.offset = &offset
	return r
}

// Maximum number of elements to return. Although up to 100.000 can be specified, it is recommended not to exceed 500 elements. Responses may be slower the more this number is exceeded. 
func (r ApiApiControllersMitreControllerGetGroupsRequest) Limit(limit int32) ApiApiControllersMitreControllerGetGroupsRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetGroupsRequest) Sort(sort string) ApiApiControllersMitreControllerGetGroupsRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersMitreControllerGetGroupsRequest) Search(search string) ApiApiControllersMitreControllerGetGroupsRequest {
	r.search = &search
	return r
}

// Select which fields to return (separated by comma). Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetGroupsRequest) Select_(select_ []string) ApiApiControllersMitreControllerGetGroupsRequest {
	r.select_ = &select_
	return r
}

// Query to filter results by. For example q&#x3D;&amp;quot;status&#x3D;active&amp;quot;
func (r ApiApiControllersMitreControllerGetGroupsRequest) Q(q string) ApiApiControllersMitreControllerGetGroupsRequest {
	r.q = &q
	return r
}

// Look for distinct values.
func (r ApiApiControllersMitreControllerGetGroupsRequest) Distinct(distinct bool) ApiApiControllersMitreControllerGetGroupsRequest {
	r.distinct = &distinct
	return r
}

func (r ApiApiControllersMitreControllerGetGroupsRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersMitreControllerGetGroupsExecute(r)
}

/*
ApiControllersMitreControllerGetGroups Get MITRE groups

Return the groups from MITRE database

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersMitreControllerGetGroupsRequest
*/
func (a *MITREAPIService) ApiControllersMitreControllerGetGroups(ctx context.Context) ApiApiControllersMitreControllerGetGroupsRequest {
	return ApiApiControllersMitreControllerGetGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *MITREAPIService) ApiControllersMitreControllerGetGroupsExecute(r ApiApiControllersMitreControllerGetGroupsRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MITREAPIService.ApiControllersMitreControllerGetGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mitre/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.groupIds != nil {
		t := *r.groupIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_ids", t, "form", "multi")
		}
	}
	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "form", "")
	} else {
		var defaultValue bool = false
		r.distinct = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersMitreControllerGetMetadataRequest struct {
	ctx context.Context
	ApiService *MITREAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersMitreControllerGetMetadataRequest) Pretty(pretty bool) ApiApiControllersMitreControllerGetMetadataRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersMitreControllerGetMetadataRequest) WaitForComplete(waitForComplete bool) ApiApiControllersMitreControllerGetMetadataRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersMitreControllerGetMetadataRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersMitreControllerGetMetadataExecute(r)
}

/*
ApiControllersMitreControllerGetMetadata Get MITRE metadata

Return the metadata from MITRE database

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersMitreControllerGetMetadataRequest
*/
func (a *MITREAPIService) ApiControllersMitreControllerGetMetadata(ctx context.Context) ApiApiControllersMitreControllerGetMetadataRequest {
	return ApiApiControllersMitreControllerGetMetadataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *MITREAPIService) ApiControllersMitreControllerGetMetadataExecute(r ApiApiControllersMitreControllerGetMetadataRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MITREAPIService.ApiControllersMitreControllerGetMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mitre/metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersMitreControllerGetMitigationsRequest struct {
	ctx context.Context
	ApiService *MITREAPIService
	mitigationIds *[]string
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
	select_ *[]string
	q *string
	distinct *bool
}

// List of MITRE&#39;s mitigations IDs (separated by comma)
func (r ApiApiControllersMitreControllerGetMitigationsRequest) MitigationIds(mitigationIds []string) ApiApiControllersMitreControllerGetMitigationsRequest {
	r.mitigationIds = &mitigationIds
	return r
}

// Show results in human-readable format
func (r ApiApiControllersMitreControllerGetMitigationsRequest) Pretty(pretty bool) ApiApiControllersMitreControllerGetMitigationsRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersMitreControllerGetMitigationsRequest) WaitForComplete(waitForComplete bool) ApiApiControllersMitreControllerGetMitigationsRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersMitreControllerGetMitigationsRequest) Offset(offset int32) ApiApiControllersMitreControllerGetMitigationsRequest {
	r.offset = &offset
	return r
}

// Maximum number of elements to return. Although up to 100.000 can be specified, it is recommended not to exceed 500 elements. Responses may be slower the more this number is exceeded. 
func (r ApiApiControllersMitreControllerGetMitigationsRequest) Limit(limit int32) ApiApiControllersMitreControllerGetMitigationsRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetMitigationsRequest) Sort(sort string) ApiApiControllersMitreControllerGetMitigationsRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersMitreControllerGetMitigationsRequest) Search(search string) ApiApiControllersMitreControllerGetMitigationsRequest {
	r.search = &search
	return r
}

// Select which fields to return (separated by comma). Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetMitigationsRequest) Select_(select_ []string) ApiApiControllersMitreControllerGetMitigationsRequest {
	r.select_ = &select_
	return r
}

// Query to filter results by. For example q&#x3D;&amp;quot;status&#x3D;active&amp;quot;
func (r ApiApiControllersMitreControllerGetMitigationsRequest) Q(q string) ApiApiControllersMitreControllerGetMitigationsRequest {
	r.q = &q
	return r
}

// Look for distinct values.
func (r ApiApiControllersMitreControllerGetMitigationsRequest) Distinct(distinct bool) ApiApiControllersMitreControllerGetMitigationsRequest {
	r.distinct = &distinct
	return r
}

func (r ApiApiControllersMitreControllerGetMitigationsRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersMitreControllerGetMitigationsExecute(r)
}

/*
ApiControllersMitreControllerGetMitigations Get MITRE mitigations

Return the mitigations from MITRE database

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersMitreControllerGetMitigationsRequest
*/
func (a *MITREAPIService) ApiControllersMitreControllerGetMitigations(ctx context.Context) ApiApiControllersMitreControllerGetMitigationsRequest {
	return ApiApiControllersMitreControllerGetMitigationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *MITREAPIService) ApiControllersMitreControllerGetMitigationsExecute(r ApiApiControllersMitreControllerGetMitigationsRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MITREAPIService.ApiControllersMitreControllerGetMitigations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mitre/mitigations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mitigationIds != nil {
		t := *r.mitigationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mitigation_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mitigation_ids", t, "form", "multi")
		}
	}
	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "form", "")
	} else {
		var defaultValue bool = false
		r.distinct = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersMitreControllerGetReferencesRequest struct {
	ctx context.Context
	ApiService *MITREAPIService
	referenceIds *[]string
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
	select_ *[]string
	q *string
}

// List of MITRE&#39;s references IDs (separated by comma)
func (r ApiApiControllersMitreControllerGetReferencesRequest) ReferenceIds(referenceIds []string) ApiApiControllersMitreControllerGetReferencesRequest {
	r.referenceIds = &referenceIds
	return r
}

// Show results in human-readable format
func (r ApiApiControllersMitreControllerGetReferencesRequest) Pretty(pretty bool) ApiApiControllersMitreControllerGetReferencesRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersMitreControllerGetReferencesRequest) WaitForComplete(waitForComplete bool) ApiApiControllersMitreControllerGetReferencesRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersMitreControllerGetReferencesRequest) Offset(offset int32) ApiApiControllersMitreControllerGetReferencesRequest {
	r.offset = &offset
	return r
}

// Maximum number of elements to return. Although up to 100.000 can be specified, it is recommended not to exceed 500 elements. Responses may be slower the more this number is exceeded. 
func (r ApiApiControllersMitreControllerGetReferencesRequest) Limit(limit int32) ApiApiControllersMitreControllerGetReferencesRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetReferencesRequest) Sort(sort string) ApiApiControllersMitreControllerGetReferencesRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersMitreControllerGetReferencesRequest) Search(search string) ApiApiControllersMitreControllerGetReferencesRequest {
	r.search = &search
	return r
}

// Select which fields to return (separated by comma). Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetReferencesRequest) Select_(select_ []string) ApiApiControllersMitreControllerGetReferencesRequest {
	r.select_ = &select_
	return r
}

// Query to filter results by. For example q&#x3D;&amp;quot;status&#x3D;active&amp;quot;
func (r ApiApiControllersMitreControllerGetReferencesRequest) Q(q string) ApiApiControllersMitreControllerGetReferencesRequest {
	r.q = &q
	return r
}

func (r ApiApiControllersMitreControllerGetReferencesRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersMitreControllerGetReferencesExecute(r)
}

/*
ApiControllersMitreControllerGetReferences Get MITRE references

Return the references from MITRE database

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersMitreControllerGetReferencesRequest
*/
func (a *MITREAPIService) ApiControllersMitreControllerGetReferences(ctx context.Context) ApiApiControllersMitreControllerGetReferencesRequest {
	return ApiApiControllersMitreControllerGetReferencesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *MITREAPIService) ApiControllersMitreControllerGetReferencesExecute(r ApiApiControllersMitreControllerGetReferencesRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MITREAPIService.ApiControllersMitreControllerGetReferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mitre/references"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.referenceIds != nil {
		t := *r.referenceIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reference_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reference_ids", t, "form", "multi")
		}
	}
	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersMitreControllerGetSoftwareRequest struct {
	ctx context.Context
	ApiService *MITREAPIService
	softwareIds *[]string
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
	select_ *[]string
	q *string
	distinct *bool
}

// List of MITRE&#39;s software IDs (separated by comma)
func (r ApiApiControllersMitreControllerGetSoftwareRequest) SoftwareIds(softwareIds []string) ApiApiControllersMitreControllerGetSoftwareRequest {
	r.softwareIds = &softwareIds
	return r
}

// Show results in human-readable format
func (r ApiApiControllersMitreControllerGetSoftwareRequest) Pretty(pretty bool) ApiApiControllersMitreControllerGetSoftwareRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersMitreControllerGetSoftwareRequest) WaitForComplete(waitForComplete bool) ApiApiControllersMitreControllerGetSoftwareRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersMitreControllerGetSoftwareRequest) Offset(offset int32) ApiApiControllersMitreControllerGetSoftwareRequest {
	r.offset = &offset
	return r
}

// Maximum number of elements to return. Although up to 100.000 can be specified, it is recommended not to exceed 500 elements. Responses may be slower the more this number is exceeded. 
func (r ApiApiControllersMitreControllerGetSoftwareRequest) Limit(limit int32) ApiApiControllersMitreControllerGetSoftwareRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetSoftwareRequest) Sort(sort string) ApiApiControllersMitreControllerGetSoftwareRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersMitreControllerGetSoftwareRequest) Search(search string) ApiApiControllersMitreControllerGetSoftwareRequest {
	r.search = &search
	return r
}

// Select which fields to return (separated by comma). Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetSoftwareRequest) Select_(select_ []string) ApiApiControllersMitreControllerGetSoftwareRequest {
	r.select_ = &select_
	return r
}

// Query to filter results by. For example q&#x3D;&amp;quot;status&#x3D;active&amp;quot;
func (r ApiApiControllersMitreControllerGetSoftwareRequest) Q(q string) ApiApiControllersMitreControllerGetSoftwareRequest {
	r.q = &q
	return r
}

// Look for distinct values.
func (r ApiApiControllersMitreControllerGetSoftwareRequest) Distinct(distinct bool) ApiApiControllersMitreControllerGetSoftwareRequest {
	r.distinct = &distinct
	return r
}

func (r ApiApiControllersMitreControllerGetSoftwareRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersMitreControllerGetSoftwareExecute(r)
}

/*
ApiControllersMitreControllerGetSoftware Get MITRE software

Return the software from MITRE database

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersMitreControllerGetSoftwareRequest
*/
func (a *MITREAPIService) ApiControllersMitreControllerGetSoftware(ctx context.Context) ApiApiControllersMitreControllerGetSoftwareRequest {
	return ApiApiControllersMitreControllerGetSoftwareRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *MITREAPIService) ApiControllersMitreControllerGetSoftwareExecute(r ApiApiControllersMitreControllerGetSoftwareRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MITREAPIService.ApiControllersMitreControllerGetSoftware")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mitre/software"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.softwareIds != nil {
		t := *r.softwareIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "software_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "software_ids", t, "form", "multi")
		}
	}
	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "form", "")
	} else {
		var defaultValue bool = false
		r.distinct = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersMitreControllerGetTacticsRequest struct {
	ctx context.Context
	ApiService *MITREAPIService
	tacticIds *[]string
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
	select_ *[]string
	q *string
	distinct *bool
}

// List of MITRE&#39;s tactics IDs (separated by comma)
func (r ApiApiControllersMitreControllerGetTacticsRequest) TacticIds(tacticIds []string) ApiApiControllersMitreControllerGetTacticsRequest {
	r.tacticIds = &tacticIds
	return r
}

// Show results in human-readable format
func (r ApiApiControllersMitreControllerGetTacticsRequest) Pretty(pretty bool) ApiApiControllersMitreControllerGetTacticsRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersMitreControllerGetTacticsRequest) WaitForComplete(waitForComplete bool) ApiApiControllersMitreControllerGetTacticsRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersMitreControllerGetTacticsRequest) Offset(offset int32) ApiApiControllersMitreControllerGetTacticsRequest {
	r.offset = &offset
	return r
}

// Maximum number of elements to return. Although up to 100.000 can be specified, it is recommended not to exceed 500 elements. Responses may be slower the more this number is exceeded. 
func (r ApiApiControllersMitreControllerGetTacticsRequest) Limit(limit int32) ApiApiControllersMitreControllerGetTacticsRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetTacticsRequest) Sort(sort string) ApiApiControllersMitreControllerGetTacticsRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersMitreControllerGetTacticsRequest) Search(search string) ApiApiControllersMitreControllerGetTacticsRequest {
	r.search = &search
	return r
}

// Select which fields to return (separated by comma). Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetTacticsRequest) Select_(select_ []string) ApiApiControllersMitreControllerGetTacticsRequest {
	r.select_ = &select_
	return r
}

// Query to filter results by. For example q&#x3D;&amp;quot;status&#x3D;active&amp;quot;
func (r ApiApiControllersMitreControllerGetTacticsRequest) Q(q string) ApiApiControllersMitreControllerGetTacticsRequest {
	r.q = &q
	return r
}

// Look for distinct values.
func (r ApiApiControllersMitreControllerGetTacticsRequest) Distinct(distinct bool) ApiApiControllersMitreControllerGetTacticsRequest {
	r.distinct = &distinct
	return r
}

func (r ApiApiControllersMitreControllerGetTacticsRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersMitreControllerGetTacticsExecute(r)
}

/*
ApiControllersMitreControllerGetTactics Get MITRE tactics

Return the tactics from MITRE database

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersMitreControllerGetTacticsRequest
*/
func (a *MITREAPIService) ApiControllersMitreControllerGetTactics(ctx context.Context) ApiApiControllersMitreControllerGetTacticsRequest {
	return ApiApiControllersMitreControllerGetTacticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *MITREAPIService) ApiControllersMitreControllerGetTacticsExecute(r ApiApiControllersMitreControllerGetTacticsRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MITREAPIService.ApiControllersMitreControllerGetTactics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mitre/tactics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tacticIds != nil {
		t := *r.tacticIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tactic_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tactic_ids", t, "form", "multi")
		}
	}
	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "form", "")
	} else {
		var defaultValue bool = false
		r.distinct = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersMitreControllerGetTechniquesRequest struct {
	ctx context.Context
	ApiService *MITREAPIService
	techniqueIds *[]string
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
	select_ *[]string
	q *string
	distinct *bool
}

// List of MITRE&#39;s techniques IDs (separated by comma)
func (r ApiApiControllersMitreControllerGetTechniquesRequest) TechniqueIds(techniqueIds []string) ApiApiControllersMitreControllerGetTechniquesRequest {
	r.techniqueIds = &techniqueIds
	return r
}

// Show results in human-readable format
func (r ApiApiControllersMitreControllerGetTechniquesRequest) Pretty(pretty bool) ApiApiControllersMitreControllerGetTechniquesRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersMitreControllerGetTechniquesRequest) WaitForComplete(waitForComplete bool) ApiApiControllersMitreControllerGetTechniquesRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersMitreControllerGetTechniquesRequest) Offset(offset int32) ApiApiControllersMitreControllerGetTechniquesRequest {
	r.offset = &offset
	return r
}

// Maximum number of elements to return. Although up to 100.000 can be specified, it is recommended not to exceed 500 elements. Responses may be slower the more this number is exceeded. 
func (r ApiApiControllersMitreControllerGetTechniquesRequest) Limit(limit int32) ApiApiControllersMitreControllerGetTechniquesRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetTechniquesRequest) Sort(sort string) ApiApiControllersMitreControllerGetTechniquesRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersMitreControllerGetTechniquesRequest) Search(search string) ApiApiControllersMitreControllerGetTechniquesRequest {
	r.search = &search
	return r
}

// Select which fields to return (separated by comma). Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersMitreControllerGetTechniquesRequest) Select_(select_ []string) ApiApiControllersMitreControllerGetTechniquesRequest {
	r.select_ = &select_
	return r
}

// Query to filter results by. For example q&#x3D;&amp;quot;status&#x3D;active&amp;quot;
func (r ApiApiControllersMitreControllerGetTechniquesRequest) Q(q string) ApiApiControllersMitreControllerGetTechniquesRequest {
	r.q = &q
	return r
}

// Look for distinct values.
func (r ApiApiControllersMitreControllerGetTechniquesRequest) Distinct(distinct bool) ApiApiControllersMitreControllerGetTechniquesRequest {
	r.distinct = &distinct
	return r
}

func (r ApiApiControllersMitreControllerGetTechniquesRequest) Execute() (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	return r.ApiService.ApiControllersMitreControllerGetTechniquesExecute(r)
}

/*
ApiControllersMitreControllerGetTechniques Get MITRE techniques

Return the techniques from MITRE database

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersMitreControllerGetTechniquesRequest
*/
func (a *MITREAPIService) ApiControllersMitreControllerGetTechniques(ctx context.Context) ApiApiControllersMitreControllerGetTechniquesRequest {
	return ApiApiControllersMitreControllerGetTechniquesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersMitreControllerGetGroups200Response
func (a *MITREAPIService) ApiControllersMitreControllerGetTechniquesExecute(r ApiApiControllersMitreControllerGetTechniquesRequest) (*ApiControllersMitreControllerGetGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersMitreControllerGetGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MITREAPIService.ApiControllersMitreControllerGetTechniques")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mitre/techniques"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.techniqueIds != nil {
		t := *r.techniqueIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "technique_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "technique_ids", t, "form", "multi")
		}
	}
	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "form", "")
	} else {
		var defaultValue bool = false
		r.distinct = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
