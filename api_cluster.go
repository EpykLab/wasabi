/*
Wazuh API REST

The Wazuh API is an open-source RESTful API that allows for interaction with the Wazuh manager from a web browser, command line tools like cURL or any script or program that can make web requests. The Wazuh WUI relies on this heavily and Wazuhâ€™s goal is to accommodate complete remote management of the Wazuh infrastructure via the Wazuh WUI. Use the Wazuh API to easily perform everyday actions like adding an agent, restarting the manager(s) or agent(s) or looking up syscheck details.  # Authentication  Wazuh API endpoints require authentication to be used. Therefore, all calls must include a JSON Web Token. JWT is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. Perform a call with `basicAuth` to `POST /security/user/authenticate` and obtain a JWT token to run any endpoint.  JWT tokens have a default duration of 900 seconds. To change this value, you must perform a call with a valid JWT token to `PUT /security/config`. After this change, you will need to get a new JWT token as all previously issued tokens are revoked when any change is performed on security configuration.  Login with USER and PASSWORD:  `curl -u <USER>:<PASSWORD> -k -X POST \"https://<HOST_IP>:55000/security/user/authenticate\"` ```json {     \"data\": {         \"token\": \"<YOUR_JWT_TOKEN>\"     },     \"error\": 0 } ``` Use the token from the previous response to perform any endpoint request:  `curl -k -X <METHOD> \"https://<HOST_IP>:55000/<ENDPOINT>\" -H  \"Authorization: Bearer <YOUR_JWT_TOKEN>\"`  Change the token base duration:  `curl -k -X PUT \"https://<HOST_IP>:55000/security/config\" -H \"Authorization: Bearer <YOUR_JWT_TOKEN>\" -d '{\"auth_token_exp_timeout\": <NEW_EXPIRE_TIME_IN_SECONDS>}'`  <SecurityDefinitions /> 

API version: 4.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"os"
)


// ClusterAPIService ClusterAPI service
type ClusterAPIService service

type ApiApiControllersClusterControllerGetApiConfigRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	pretty *bool
	waitForComplete *bool
	nodesList *[]string
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetApiConfigRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetApiConfigRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetApiConfigRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetApiConfigRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// List of node IDs (separated by comma), all nodes selected by default if not specified
func (r ApiApiControllersClusterControllerGetApiConfigRequest) NodesList(nodesList []string) ApiApiControllersClusterControllerGetApiConfigRequest {
	r.nodesList = &nodesList
	return r
}

func (r ApiApiControllersClusterControllerGetApiConfigRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetApiConfigExecute(r)
}

/*
ApiControllersClusterControllerGetApiConfig Get nodes API config

Return the API configuration of all nodes (or a list of them) in JSON format

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersClusterControllerGetApiConfigRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetApiConfig(ctx context.Context) ApiApiControllersClusterControllerGetApiConfigRequest {
	return ApiApiControllersClusterControllerGetApiConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ClusterAPIService) ApiControllersClusterControllerGetApiConfigExecute(r ApiApiControllersClusterControllerGetApiConfigRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetApiConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/api/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.nodesList != nil {
		t := *r.nodesList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetClusterNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetClusterNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetClusterNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetClusterNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetClusterNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerGetClusterNodeRequest) Execute() (*ApiControllersClusterControllerGetClusterNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetClusterNodeExecute(r)
}

/*
ApiControllersClusterControllerGetClusterNode Get local node info

Return basic information about the cluster node receiving the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersClusterControllerGetClusterNodeRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetClusterNode(ctx context.Context) ApiApiControllersClusterControllerGetClusterNodeRequest {
	return ApiApiControllersClusterControllerGetClusterNodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetClusterNode200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetClusterNodeExecute(r ApiApiControllersClusterControllerGetClusterNodeRequest) (*ApiControllersClusterControllerGetClusterNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetClusterNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetClusterNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/local/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetClusterNodesRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
	select_ *[]string
	type_ *string
	nodesList *[]string
	q *string
	distinct *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetClusterNodesRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetClusterNodesRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetClusterNodesRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetClusterNodesRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersClusterControllerGetClusterNodesRequest) Offset(offset int32) ApiApiControllersClusterControllerGetClusterNodesRequest {
	r.offset = &offset
	return r
}

// Maximum number of elements to return. Although up to 100.000 can be specified, it is recommended not to exceed 500 elements. Responses may be slower the more this number is exceeded. 
func (r ApiApiControllersClusterControllerGetClusterNodesRequest) Limit(limit int32) ApiApiControllersClusterControllerGetClusterNodesRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersClusterControllerGetClusterNodesRequest) Sort(sort string) ApiApiControllersClusterControllerGetClusterNodesRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersClusterControllerGetClusterNodesRequest) Search(search string) ApiApiControllersClusterControllerGetClusterNodesRequest {
	r.search = &search
	return r
}

// Select which fields to return (separated by comma). Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersClusterControllerGetClusterNodesRequest) Select_(select_ []string) ApiApiControllersClusterControllerGetClusterNodesRequest {
	r.select_ = &select_
	return r
}

// Filter by node type
func (r ApiApiControllersClusterControllerGetClusterNodesRequest) Type_(type_ string) ApiApiControllersClusterControllerGetClusterNodesRequest {
	r.type_ = &type_
	return r
}

// List of node IDs (separated by comma), all nodes selected by default if not specified
func (r ApiApiControllersClusterControllerGetClusterNodesRequest) NodesList(nodesList []string) ApiApiControllersClusterControllerGetClusterNodesRequest {
	r.nodesList = &nodesList
	return r
}

// Query to filter results by. For example q&#x3D;&amp;quot;status&#x3D;active&amp;quot;
func (r ApiApiControllersClusterControllerGetClusterNodesRequest) Q(q string) ApiApiControllersClusterControllerGetClusterNodesRequest {
	r.q = &q
	return r
}

// Look for distinct values.
func (r ApiApiControllersClusterControllerGetClusterNodesRequest) Distinct(distinct bool) ApiApiControllersClusterControllerGetClusterNodesRequest {
	r.distinct = &distinct
	return r
}

func (r ApiApiControllersClusterControllerGetClusterNodesRequest) Execute() (*ApiControllersClusterControllerGetClusterNodes200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetClusterNodesExecute(r)
}

/*
ApiControllersClusterControllerGetClusterNodes Get nodes info

Get information about all nodes in the cluster or a list of them

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersClusterControllerGetClusterNodesRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetClusterNodes(ctx context.Context) ApiApiControllersClusterControllerGetClusterNodesRequest {
	return ApiApiControllersClusterControllerGetClusterNodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetClusterNodes200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetClusterNodesExecute(r ApiApiControllersClusterControllerGetClusterNodesRequest) (*ApiControllersClusterControllerGetClusterNodes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetClusterNodes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetClusterNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/nodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.nodesList != nil {
		t := *r.nodesList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "form", "")
	} else {
		var defaultValue bool = false
		r.distinct = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetConfValidationRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	pretty *bool
	waitForComplete *bool
	nodesList *[]string
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetConfValidationRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetConfValidationRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetConfValidationRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetConfValidationRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// List of node IDs (separated by comma), all nodes selected by default if not specified
func (r ApiApiControllersClusterControllerGetConfValidationRequest) NodesList(nodesList []string) ApiApiControllersClusterControllerGetConfValidationRequest {
	r.nodesList = &nodesList
	return r
}

func (r ApiApiControllersClusterControllerGetConfValidationRequest) Execute() (*ApiControllersClusterControllerGetConfValidation200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetConfValidationExecute(r)
}

/*
ApiControllersClusterControllerGetConfValidation Check nodes config

Return whether the Wazuh configuration is correct or not in all cluster nodes or a list of them

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersClusterControllerGetConfValidationRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetConfValidation(ctx context.Context) ApiApiControllersClusterControllerGetConfValidationRequest {
	return ApiApiControllersClusterControllerGetConfValidationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetConfValidation200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetConfValidationExecute(r ApiApiControllersClusterControllerGetConfValidationRequest) (*ApiControllersClusterControllerGetConfValidation200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetConfValidation200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetConfValidation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/configuration/validation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.nodesList != nil {
		t := *r.nodesList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetConfigRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetConfigRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetConfigRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetConfigRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetConfigRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerGetConfigRequest) Execute() (*ApiControllersClusterControllerGetConfig200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetConfigExecute(r)
}

/*
ApiControllersClusterControllerGetConfig Get local node config

Return the current node cluster configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersClusterControllerGetConfigRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetConfig(ctx context.Context) ApiApiControllersClusterControllerGetConfigRequest {
	return ApiApiControllersClusterControllerGetConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetConfig200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetConfigExecute(r ApiApiControllersClusterControllerGetConfigRequest) (*ApiControllersClusterControllerGetConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/local/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetConfigurationNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	pretty *bool
	waitForComplete *bool
	raw *bool
	section *string
	field *string
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetConfigurationNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetConfigurationNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetConfigurationNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetConfigurationNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// Format response in plain text
func (r ApiApiControllersClusterControllerGetConfigurationNodeRequest) Raw(raw bool) ApiApiControllersClusterControllerGetConfigurationNodeRequest {
	r.raw = &raw
	return r
}

// Indicates the wazuh configuration section
func (r ApiApiControllersClusterControllerGetConfigurationNodeRequest) Section(section string) ApiApiControllersClusterControllerGetConfigurationNodeRequest {
	r.section = &section
	return r
}

// Indicate a section child. E.g, fields for *ruleset* section are: decoder_dir, rule_dir, etc
func (r ApiApiControllersClusterControllerGetConfigurationNodeRequest) Field(field string) ApiApiControllersClusterControllerGetConfigurationNodeRequest {
	r.field = &field
	return r
}

func (r ApiApiControllersClusterControllerGetConfigurationNodeRequest) Execute() (*ApiControllersClusterControllerGetConfigurationNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetConfigurationNodeExecute(r)
}

/*
ApiControllersClusterControllerGetConfigurationNode Get node config

Return wazuh configuration used in node {node_id}. The 'section' and 'field' parameters will be ignored if 'raw' parameter is provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerGetConfigurationNodeRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetConfigurationNode(ctx context.Context, nodeId string) ApiApiControllersClusterControllerGetConfigurationNodeRequest {
	return ApiApiControllersClusterControllerGetConfigurationNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetConfigurationNode200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetConfigurationNodeExecute(r ApiApiControllersClusterControllerGetConfigurationNodeRequest) (*ApiControllersClusterControllerGetConfigurationNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetConfigurationNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetConfigurationNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.raw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "raw", r.raw, "form", "")
	}
	if r.section != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "section", r.section, "form", "")
	}
	if r.field != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field", r.field, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetDaemonStatsNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	pretty *bool
	waitForComplete *bool
	daemonsList *[]string
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetDaemonStatsNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetDaemonStatsNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetDaemonStatsNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetDaemonStatsNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// List of daemon names (separated by comma), all daemons selected by default if not specified
func (r ApiApiControllersClusterControllerGetDaemonStatsNodeRequest) DaemonsList(daemonsList []string) ApiApiControllersClusterControllerGetDaemonStatsNodeRequest {
	r.daemonsList = &daemonsList
	return r
}

func (r ApiApiControllersClusterControllerGetDaemonStatsNodeRequest) Execute() (*ApiControllersClusterControllerGetDaemonStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetDaemonStatsNodeExecute(r)
}

/*
ApiControllersClusterControllerGetDaemonStatsNode Get Wazuh daemon stats from a cluster node

Return Wazuh statistical information from specified daemons in a specified cluster node

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerGetDaemonStatsNodeRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetDaemonStatsNode(ctx context.Context, nodeId string) ApiApiControllersClusterControllerGetDaemonStatsNodeRequest {
	return ApiApiControllersClusterControllerGetDaemonStatsNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetDaemonStatsNode200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetDaemonStatsNodeExecute(r ApiApiControllersClusterControllerGetDaemonStatsNodeRequest) (*ApiControllersClusterControllerGetDaemonStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetDaemonStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetDaemonStatsNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/daemons/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.daemonsList != nil {
		t := *r.daemonsList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "daemons_list", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "daemons_list", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetHealthcheckRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	pretty *bool
	waitForComplete *bool
	nodesList *[]string
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetHealthcheckRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetHealthcheckRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetHealthcheckRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetHealthcheckRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// List of node IDs (separated by comma), all nodes selected by default if not specified
func (r ApiApiControllersClusterControllerGetHealthcheckRequest) NodesList(nodesList []string) ApiApiControllersClusterControllerGetHealthcheckRequest {
	r.nodesList = &nodesList
	return r
}

func (r ApiApiControllersClusterControllerGetHealthcheckRequest) Execute() (*ApiControllersClusterControllerGetHealthcheck200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetHealthcheckExecute(r)
}

/*
ApiControllersClusterControllerGetHealthcheck Get nodes healthcheck

Return cluster healthcheck information for all nodes or a list of them. Such information includes last keep alive, last synchronization time and number of agents reporting on each node

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersClusterControllerGetHealthcheckRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetHealthcheck(ctx context.Context) ApiApiControllersClusterControllerGetHealthcheckRequest {
	return ApiApiControllersClusterControllerGetHealthcheckRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetHealthcheck200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetHealthcheckExecute(r ApiApiControllersClusterControllerGetHealthcheckRequest) (*ApiControllersClusterControllerGetHealthcheck200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetHealthcheck200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetHealthcheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/healthcheck"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.nodesList != nil {
		t := *r.nodesList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetInfoNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetInfoNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetInfoNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetInfoNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetInfoNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerGetInfoNodeRequest) Execute() (*ApiControllersClusterControllerGetInfoNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetInfoNodeExecute(r)
}

/*
ApiControllersClusterControllerGetInfoNode Get node info

Return basic information about a specified node such as version, compilation date, installation path

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerGetInfoNodeRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetInfoNode(ctx context.Context, nodeId string) ApiApiControllersClusterControllerGetInfoNodeRequest {
	return ApiApiControllersClusterControllerGetInfoNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetInfoNode200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetInfoNodeExecute(r ApiApiControllersClusterControllerGetInfoNodeRequest) (*ApiControllersClusterControllerGetInfoNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetInfoNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetInfoNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/info"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetLogNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
	tag *string
	level *string
	q *string
	select_ *[]string
	distinct *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetLogNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetLogNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetLogNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetLogNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersClusterControllerGetLogNodeRequest) Offset(offset int32) ApiApiControllersClusterControllerGetLogNodeRequest {
	r.offset = &offset
	return r
}

// Maximum number of lines to return.
func (r ApiApiControllersClusterControllerGetLogNodeRequest) Limit(limit int32) ApiApiControllersClusterControllerGetLogNodeRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersClusterControllerGetLogNodeRequest) Sort(sort string) ApiApiControllersClusterControllerGetLogNodeRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersClusterControllerGetLogNodeRequest) Search(search string) ApiApiControllersClusterControllerGetLogNodeRequest {
	r.search = &search
	return r
}

// Wazuh component that logged the event
func (r ApiApiControllersClusterControllerGetLogNodeRequest) Tag(tag string) ApiApiControllersClusterControllerGetLogNodeRequest {
	r.tag = &tag
	return r
}

// Filter by log level
func (r ApiApiControllersClusterControllerGetLogNodeRequest) Level(level string) ApiApiControllersClusterControllerGetLogNodeRequest {
	r.level = &level
	return r
}

// Query to filter results by. For example q&#x3D;&amp;quot;status&#x3D;active&amp;quot;
func (r ApiApiControllersClusterControllerGetLogNodeRequest) Q(q string) ApiApiControllersClusterControllerGetLogNodeRequest {
	r.q = &q
	return r
}

// Select which fields to return (separated by comma). Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersClusterControllerGetLogNodeRequest) Select_(select_ []string) ApiApiControllersClusterControllerGetLogNodeRequest {
	r.select_ = &select_
	return r
}

// Look for distinct values.
func (r ApiApiControllersClusterControllerGetLogNodeRequest) Distinct(distinct bool) ApiApiControllersClusterControllerGetLogNodeRequest {
	r.distinct = &distinct
	return r
}

func (r ApiApiControllersClusterControllerGetLogNodeRequest) Execute() (*ApiControllersClusterControllerGetLogNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetLogNodeExecute(r)
}

/*
ApiControllersClusterControllerGetLogNode Get node logs

Return the last 2000 wazuh log entries in the specified node

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerGetLogNodeRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetLogNode(ctx context.Context, nodeId string) ApiApiControllersClusterControllerGetLogNodeRequest {
	return ApiApiControllersClusterControllerGetLogNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetLogNode200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetLogNodeExecute(r ApiApiControllersClusterControllerGetLogNodeRequest) (*ApiControllersClusterControllerGetLogNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetLogNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetLogNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "form", "")
	} else {
		var defaultValue bool = false
		r.distinct = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetLogSummaryNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetLogSummaryNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetLogSummaryNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetLogSummaryNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetLogSummaryNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerGetLogSummaryNodeRequest) Execute() (*ApiControllersClusterControllerGetLogSummaryNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetLogSummaryNodeExecute(r)
}

/*
ApiControllersClusterControllerGetLogSummaryNode Get node logs summary

Return a summary of the last 2000 wazuh log entries in the specified node

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerGetLogSummaryNodeRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetLogSummaryNode(ctx context.Context, nodeId string) ApiApiControllersClusterControllerGetLogSummaryNodeRequest {
	return ApiApiControllersClusterControllerGetLogSummaryNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetLogSummaryNode200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetLogSummaryNodeExecute(r ApiApiControllersClusterControllerGetLogSummaryNodeRequest) (*ApiControllersClusterControllerGetLogSummaryNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetLogSummaryNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetLogSummaryNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/logs/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetNodeConfigRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	component string
	configuration string
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetNodeConfigRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetNodeConfigRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetNodeConfigRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetNodeConfigRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerGetNodeConfigRequest) Execute() (*ApiControllersClusterControllerGetNodeConfig200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetNodeConfigExecute(r)
}

/*
ApiControllersClusterControllerGetNodeConfig Get node active configuration

Return the requested configuration in JSON format for the specified node

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @param component Selected agent's component
 @param configuration <p>Selected agent's configuration to read. The configuration to read depends on the selected component. The following table shows all available combinations of component and configuration values:</p> <table class=\"table table-striped table-bordered\"> <thead> <tr> <th>Component</th> <th>Configuration</th> <th>Tag</th> </tr> </thead> <tbody> <tr> <td>agent</td> <td>client</td> <td><code>&lt;client&gt;</code></td> </tr> <tr> <td>agent</td> <td>buffer</td> <td><code>&lt;client_buffer&gt;</code></td> </tr> <tr> <td>agent</td> <td>labels</td> <td><code>&lt;labels&gt;</code></td> </tr> <tr> <td>agent</td> <td>internal</td> <td><code>&lt;agent&gt;</code>, <code>&lt;monitord&gt;</code>, <code>&lt;remoted&gt;</code></td> </tr> <tr> <td>agent</td> <td>anti_tampering</td> <td><code>&lt;anti_tampering&gt;</code></td> </tr> <tr> <td>agentless</td> <td>agentless</td> <td><code>&lt;agentless&gt;</code></td> </tr> <tr> <td>analysis</td> <td>global</td> <td><code>&lt;global&gt;</code></td> </tr> <tr> <td>analysis</td> <td>active_response</td> <td><code>&lt;active-response&gt;</code></td> </tr> <tr> <td>analysis</td> <td>alerts</td> <td><code>&lt;alerts&gt;</code></td> </tr> <tr> <td>analysis</td> <td>command</td> <td><code>&lt;command&gt;</code></td> </tr> <tr> <td>analysis</td> <td>rules</td> <td><code>&lt;rule&gt;</code></td> </tr> <tr> <td>analysis</td> <td>decoders</td> <td><code>&lt;decoder&gt;</code></td> </tr> <tr> <td>analysis</td> <td>internal</td> <td><code>&lt;analysisd&gt;</code></td> </tr> <tr> <td>analysis</td> <td>rule_test</td> <td><code>&lt;rule_test&gt;</code></td> </tr> <tr> <td>auth</td> <td>auth</td> <td><code>&lt;auth&gt;</code></td> </tr> <tr> <td>com</td> <td>active-response</td> <td><code>&lt;active-response&gt;</code></td> </tr> <tr> <td>com</td> <td>logging</td> <td><code>&lt;logging&gt;</code></td> </tr> <tr> <td>com</td> <td>internal</td> <td><code>&lt;execd&gt;</code></td> </tr> <tr> <td>com</td> <td>cluster</td> <td><code>&lt;cluster&gt;</code></td> </tr> <tr> <td>csyslog</td> <td>csyslog</td> <td><code>&lt;csyslog_output&gt;</code></td> </tr> <tr> <td>integrator</td> <td>integration</td> <td><code>&lt;integration&gt;</code></td> </tr> <tr> <td>logcollector</td> <td>localfile</td> <td><code>&lt;localfile&gt;</code></td> </tr> <tr> <td>logcollector</td> <td>socket</td> <td><code>&lt;socket&gt;</code></td> </tr> <tr> <td>logcollector</td> <td>internal</td> <td><code>&lt;logcollector&gt;</code></td> </tr> <tr> <td>mail</td> <td>global</td> <td><code>&lt;global&gt;&lt;email...&gt;</code></td> </tr> <tr> <td>mail</td> <td>alerts</td> <td><code>&lt;email_alerts&gt;</code></td> </tr> <tr> <td>mail</td> <td>internal</td> <td><code>&lt;maild&gt;</code></td> </tr> <tr> <td>monitor</td> <td>global</td> <td><code>&lt;global&gt;</code></td> </tr> <tr> <td>monitor</td> <td>internal</td> <td><code>&lt;monitord&gt;</code></td> </tr> <tr> <td>monitor</td> <td>reports</td> <td><code>&lt;reports&gt;</code></td> </tr> <tr> <td>request</td> <td>global</td> <td><code>&lt;global&gt;</code></td> </tr> <tr> <td>request</td> <td>remote</td> <td><code>&lt;remote&gt;</code></td> </tr> <tr> <td>request</td> <td>internal</td> <td><code>&lt;remoted&gt;</code></td> </tr> <tr> <td>syscheck</td> <td>syscheck</td> <td><code>&lt;syscheck&gt;</code></td> </tr> <tr> <td>syscheck</td> <td>rootcheck</td> <td><code>&lt;rootcheck&gt;</code></td> </tr> <tr> <td>syscheck</td> <td>internal</td> <td><code>&lt;syscheck&gt;</code>, <code>&lt;rootcheck&gt;</code></td> </tr> <tr> <td>wazuh-db</td> <td>internal</td> <td><code>&lt;wazuh_db&gt;</code></td> </tr> <tr> <td>wazuh-db</td> <td>wdb</td> <td><code>&lt;wdb&gt;</code></td> </tr> <tr> <td>wmodules</td> <td>wmodules</td> <td><code>&lt;wodle&gt;</code></td> </tr> </tbody> </table> 
 @return ApiApiControllersClusterControllerGetNodeConfigRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetNodeConfig(ctx context.Context, nodeId string, component string, configuration string) ApiApiControllersClusterControllerGetNodeConfigRequest {
	return ApiApiControllersClusterControllerGetNodeConfigRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
		component: component,
		configuration: configuration,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetNodeConfig200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetNodeConfigExecute(r ApiApiControllersClusterControllerGetNodeConfigRequest) (*ApiControllersClusterControllerGetNodeConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetNodeConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetNodeConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/configuration/{component}/{configuration}"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterValueToString(r.component, "component")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configuration"+"}", url.PathEscape(parameterValueToString(r.configuration, "configuration")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	pretty *bool
	waitForComplete *bool
	nodesList *[]string
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// List of node IDs (separated by comma), all nodes selected by default if not specified
func (r ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest) NodesList(nodesList []string) ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest {
	r.nodesList = &nodesList
	return r
}

func (r ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest) Execute() (*ApiControllersClusterControllerGetNodesRulesetSyncStatus200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetNodesRulesetSyncStatusExecute(r)
}

/*
ApiControllersClusterControllerGetNodesRulesetSyncStatus Get cluster nodes ruleset synchronization status

Return ruleset synchronization status for all nodes or a list of them. This synchronization only covers the user custom ruleset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetNodesRulesetSyncStatus(ctx context.Context) ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest {
	return ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetNodesRulesetSyncStatus200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetNodesRulesetSyncStatusExecute(r ApiApiControllersClusterControllerGetNodesRulesetSyncStatusRequest) (*ApiControllersClusterControllerGetNodesRulesetSyncStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetNodesRulesetSyncStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetNodesRulesetSyncStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/ruleset/synchronization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.nodesList != nil {
		t := *r.nodesList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetStatsAnalysisdNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetStatsAnalysisdNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetStatsAnalysisdNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetStatsAnalysisdNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetStatsAnalysisdNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerGetStatsAnalysisdNodeRequest) Execute() (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetStatsAnalysisdNodeExecute(r)
}

/*
ApiControllersClusterControllerGetStatsAnalysisdNode Get node stats analysisd

Return Wazuh analysisd statistical information in node {node_id}

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerGetStatsAnalysisdNodeRequest

Deprecated
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatsAnalysisdNode(ctx context.Context, nodeId string) ApiApiControllersClusterControllerGetStatsAnalysisdNodeRequest {
	return ApiApiControllersClusterControllerGetStatsAnalysisdNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatsNode200Response
// Deprecated
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatsAnalysisdNodeExecute(r ApiApiControllersClusterControllerGetStatsAnalysisdNodeRequest) (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetStatsAnalysisdNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/stats/analysisd"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetStatsHourlyNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetStatsHourlyNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetStatsHourlyNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetStatsHourlyNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetStatsHourlyNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerGetStatsHourlyNodeRequest) Execute() (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetStatsHourlyNodeExecute(r)
}

/*
ApiControllersClusterControllerGetStatsHourlyNode Get node stats hour

Return Wazuh statistical information in node {node_id} per hour. Each number in the averages field represents the average of alerts per hour

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerGetStatsHourlyNodeRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatsHourlyNode(ctx context.Context, nodeId string) ApiApiControllersClusterControllerGetStatsHourlyNodeRequest {
	return ApiApiControllersClusterControllerGetStatsHourlyNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatsNode200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatsHourlyNodeExecute(r ApiApiControllersClusterControllerGetStatsHourlyNodeRequest) (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetStatsHourlyNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/stats/hourly"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetStatsNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	pretty *bool
	waitForComplete *bool
	date *string
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetStatsNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetStatsNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetStatsNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetStatsNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// Date to obtain statistical information from. Format YYYY-MM-DD
func (r ApiApiControllersClusterControllerGetStatsNodeRequest) Date(date string) ApiApiControllersClusterControllerGetStatsNodeRequest {
	r.date = &date
	return r
}

func (r ApiApiControllersClusterControllerGetStatsNodeRequest) Execute() (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetStatsNodeExecute(r)
}

/*
ApiControllersClusterControllerGetStatsNode Get node stats

Return Wazuh statistical information in node {node_id} for the current or specified date

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerGetStatsNodeRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatsNode(ctx context.Context, nodeId string) ApiApiControllersClusterControllerGetStatsNodeRequest {
	return ApiApiControllersClusterControllerGetStatsNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatsNode200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatsNodeExecute(r ApiApiControllersClusterControllerGetStatsNodeRequest) (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetStatsNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetStatsRemotedNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetStatsRemotedNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetStatsRemotedNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetStatsRemotedNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetStatsRemotedNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerGetStatsRemotedNodeRequest) Execute() (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetStatsRemotedNodeExecute(r)
}

/*
ApiControllersClusterControllerGetStatsRemotedNode Get node stats remoted

Return Wazuh remoted statistical information in node {node_id}

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerGetStatsRemotedNodeRequest

Deprecated
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatsRemotedNode(ctx context.Context, nodeId string) ApiApiControllersClusterControllerGetStatsRemotedNodeRequest {
	return ApiApiControllersClusterControllerGetStatsRemotedNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatsNode200Response
// Deprecated
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatsRemotedNodeExecute(r ApiApiControllersClusterControllerGetStatsRemotedNodeRequest) (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetStatsRemotedNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/stats/remoted"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetStatsWeeklyNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetStatsWeeklyNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetStatsWeeklyNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetStatsWeeklyNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetStatsWeeklyNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerGetStatsWeeklyNodeRequest) Execute() (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetStatsWeeklyNodeExecute(r)
}

/*
ApiControllersClusterControllerGetStatsWeeklyNode Get node stats week

Return Wazuh statistical information in node {node_id} per week. Each number in the averages field represents the average of alerts per hour for that specific day

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerGetStatsWeeklyNodeRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatsWeeklyNode(ctx context.Context, nodeId string) ApiApiControllersClusterControllerGetStatsWeeklyNodeRequest {
	return ApiApiControllersClusterControllerGetStatsWeeklyNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatsNode200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatsWeeklyNodeExecute(r ApiApiControllersClusterControllerGetStatsWeeklyNodeRequest) (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetStatsWeeklyNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/stats/weekly"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetStatusRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetStatusRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetStatusRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetStatusRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetStatusRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerGetStatusRequest) Execute() (*ApiControllersClusterControllerGetStatus200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetStatusExecute(r)
}

/*
ApiControllersClusterControllerGetStatus Get cluster status

Return information about the cluster status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersClusterControllerGetStatusRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatus(ctx context.Context) ApiApiControllersClusterControllerGetStatusRequest {
	return ApiApiControllersClusterControllerGetStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatus200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatusExecute(r ApiApiControllersClusterControllerGetStatusRequest) (*ApiControllersClusterControllerGetStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerGetStatusNodeRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerGetStatusNodeRequest) Pretty(pretty bool) ApiApiControllersClusterControllerGetStatusNodeRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerGetStatusNodeRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerGetStatusNodeRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerGetStatusNodeRequest) Execute() (*ApiControllersClusterControllerGetStatusNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerGetStatusNodeExecute(r)
}

/*
ApiControllersClusterControllerGetStatusNode Get node status

Return the status of all Wazuh daemons in node node_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerGetStatusNodeRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatusNode(ctx context.Context, nodeId string) ApiApiControllersClusterControllerGetStatusNodeRequest {
	return ApiApiControllersClusterControllerGetStatusNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatusNode200Response
func (a *ClusterAPIService) ApiControllersClusterControllerGetStatusNodeExecute(r ApiApiControllersClusterControllerGetStatusNodeRequest) (*ApiControllersClusterControllerGetStatusNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatusNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerGetStatusNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerPutRestartRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	pretty *bool
	waitForComplete *bool
	nodesList *[]string
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerPutRestartRequest) Pretty(pretty bool) ApiApiControllersClusterControllerPutRestartRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerPutRestartRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerPutRestartRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// List of node IDs (separated by comma), all nodes selected by default if not specified
func (r ApiApiControllersClusterControllerPutRestartRequest) NodesList(nodesList []string) ApiApiControllersClusterControllerPutRestartRequest {
	r.nodesList = &nodesList
	return r
}

func (r ApiApiControllersClusterControllerPutRestartRequest) Execute() (*ApiControllersClusterControllerPutRestart200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerPutRestartExecute(r)
}

/*
ApiControllersClusterControllerPutRestart Restart nodes

Restart all nodes in the cluster or a list of them

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersClusterControllerPutRestartRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerPutRestart(ctx context.Context) ApiApiControllersClusterControllerPutRestartRequest {
	return ApiApiControllersClusterControllerPutRestartRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerPutRestart200Response
func (a *ClusterAPIService) ApiControllersClusterControllerPutRestartExecute(r ApiApiControllersClusterControllerPutRestartRequest) (*ApiControllersClusterControllerPutRestart200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerPutRestart200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerPutRestart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/restart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.nodesList != nil {
		t := *r.nodesList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_list", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersClusterControllerUpdateConfigurationRequest struct {
	ctx context.Context
	ApiService *ClusterAPIService
	nodeId string
	body *os.File
	pretty *bool
	waitForComplete *bool
}

// Content of the ossec.conf to be uploaded
func (r ApiApiControllersClusterControllerUpdateConfigurationRequest) Body(body *os.File) ApiApiControllersClusterControllerUpdateConfigurationRequest {
	r.body = body
	return r
}

// Show results in human-readable format
func (r ApiApiControllersClusterControllerUpdateConfigurationRequest) Pretty(pretty bool) ApiApiControllersClusterControllerUpdateConfigurationRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersClusterControllerUpdateConfigurationRequest) WaitForComplete(waitForComplete bool) ApiApiControllersClusterControllerUpdateConfigurationRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersClusterControllerUpdateConfigurationRequest) Execute() (*ApiControllersClusterControllerUpdateConfiguration200Response, *http.Response, error) {
	return r.ApiService.ApiControllersClusterControllerUpdateConfigurationExecute(r)
}

/*
ApiControllersClusterControllerUpdateConfiguration Update node configuration

Replace wazuh configuration for the given node with the data contained in the API request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Cluster node name
 @return ApiApiControllersClusterControllerUpdateConfigurationRequest
*/
func (a *ClusterAPIService) ApiControllersClusterControllerUpdateConfiguration(ctx context.Context, nodeId string) ApiApiControllersClusterControllerUpdateConfigurationRequest {
	return ApiApiControllersClusterControllerUpdateConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerUpdateConfiguration200Response
func (a *ClusterAPIService) ApiControllersClusterControllerUpdateConfigurationExecute(r ApiApiControllersClusterControllerUpdateConfigurationRequest) (*ApiControllersClusterControllerUpdateConfiguration200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerUpdateConfiguration200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClusterAPIService.ApiControllersClusterControllerUpdateConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cluster/{node_id}/configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
