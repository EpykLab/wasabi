/*
Wazuh API REST

The Wazuh API is an open-source RESTful API that allows for interaction with the Wazuh manager from a web browser, command line tools like cURL or any script or program that can make web requests. The Wazuh WUI relies on this heavily and Wazuhâ€™s goal is to accommodate complete remote management of the Wazuh infrastructure via the Wazuh WUI. Use the Wazuh API to easily perform everyday actions like adding an agent, restarting the manager(s) or agent(s) or looking up syscheck details.  # Authentication  Wazuh API endpoints require authentication to be used. Therefore, all calls must include a JSON Web Token. JWT is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. Perform a call with `basicAuth` to `POST /security/user/authenticate` and obtain a JWT token to run any endpoint.  JWT tokens have a default duration of 900 seconds. To change this value, you must perform a call with a valid JWT token to `PUT /security/config`. After this change, you will need to get a new JWT token as all previously issued tokens are revoked when any change is performed on security configuration.  Login with USER and PASSWORD:  `curl -u <USER>:<PASSWORD> -k -X POST \"https://<HOST_IP>:55000/security/user/authenticate\"` ```json {     \"data\": {         \"token\": \"<YOUR_JWT_TOKEN>\"     },     \"error\": 0 } ``` Use the token from the previous response to perform any endpoint request:  `curl -k -X <METHOD> \"https://<HOST_IP>:55000/<ENDPOINT>\" -H  \"Authorization: Bearer <YOUR_JWT_TOKEN>\"`  Change the token base duration:  `curl -k -X PUT \"https://<HOST_IP>:55000/security/config\" -H \"Authorization: Bearer <YOUR_JWT_TOKEN>\" -d '{\"auth_token_exp_timeout\": <NEW_EXPIRE_TIME_IN_SECONDS>}'`  <SecurityDefinitions /> 

API version: 4.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"os"
)


// ManagerAPIService ManagerAPI service
type ManagerAPIService service

type ApiApiControllersManagerControllerCheckAvailableVersionRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	forceQuery *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerCheckAvailableVersionRequest) Pretty(pretty bool) ApiApiControllersManagerControllerCheckAvailableVersionRequest {
	r.pretty = &pretty
	return r
}

// Force query to CTI service
func (r ApiApiControllersManagerControllerCheckAvailableVersionRequest) ForceQuery(forceQuery bool) ApiApiControllersManagerControllerCheckAvailableVersionRequest {
	r.forceQuery = &forceQuery
	return r
}

func (r ApiApiControllersManagerControllerCheckAvailableVersionRequest) Execute() (*ApiControllersManagerControllerCheckAvailableVersion200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerCheckAvailableVersionExecute(r)
}

/*
ApiControllersManagerControllerCheckAvailableVersion Check available updates

Return if there is any available update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerCheckAvailableVersionRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerCheckAvailableVersion(ctx context.Context) ApiApiControllersManagerControllerCheckAvailableVersionRequest {
	return ApiApiControllersManagerControllerCheckAvailableVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersManagerControllerCheckAvailableVersion200Response
func (a *ManagerAPIService) ApiControllersManagerControllerCheckAvailableVersionExecute(r ApiApiControllersManagerControllerCheckAvailableVersionRequest) (*ApiControllersManagerControllerCheckAvailableVersion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersManagerControllerCheckAvailableVersion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerCheckAvailableVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/version/check"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.forceQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force_query", r.forceQuery, "form", "")
	} else {
		var defaultValue bool = false
		r.forceQuery = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetApiConfigRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetApiConfigRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetApiConfigRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetApiConfigRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetApiConfigRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerGetApiConfigRequest) Execute() (*ApiResponse, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetApiConfigExecute(r)
}

/*
ApiControllersManagerControllerGetApiConfig Get API config

Return the local API configuration in JSON format

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetApiConfigRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetApiConfig(ctx context.Context) ApiApiControllersManagerControllerGetApiConfigRequest {
	return ApiApiControllersManagerControllerGetApiConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiResponse
func (a *ManagerAPIService) ApiControllersManagerControllerGetApiConfigExecute(r ApiApiControllersManagerControllerGetApiConfigRequest) (*ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetApiConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/api/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetConfValidationRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetConfValidationRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetConfValidationRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetConfValidationRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetConfValidationRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerGetConfValidationRequest) Execute() (*ConfigurationValidation, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetConfValidationExecute(r)
}

/*
ApiControllersManagerControllerGetConfValidation Check config

Return whether the Wazuh configuration is correct

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetConfValidationRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetConfValidation(ctx context.Context) ApiApiControllersManagerControllerGetConfValidationRequest {
	return ApiApiControllersManagerControllerGetConfValidationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigurationValidation
func (a *ManagerAPIService) ApiControllersManagerControllerGetConfValidationExecute(r ApiApiControllersManagerControllerGetConfValidationRequest) (*ConfigurationValidation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigurationValidation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetConfValidation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/configuration/validation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetConfigurationRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
	raw *bool
	section *string
	field *string
	distinct *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetConfigurationRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetConfigurationRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetConfigurationRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetConfigurationRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// Format response in plain text
func (r ApiApiControllersManagerControllerGetConfigurationRequest) Raw(raw bool) ApiApiControllersManagerControllerGetConfigurationRequest {
	r.raw = &raw
	return r
}

// Indicates the wazuh configuration section
func (r ApiApiControllersManagerControllerGetConfigurationRequest) Section(section string) ApiApiControllersManagerControllerGetConfigurationRequest {
	r.section = &section
	return r
}

// Indicate a section child. E.g, fields for *ruleset* section are: decoder_dir, rule_dir, etc
func (r ApiApiControllersManagerControllerGetConfigurationRequest) Field(field string) ApiApiControllersManagerControllerGetConfigurationRequest {
	r.field = &field
	return r
}

// Look for distinct values.
func (r ApiApiControllersManagerControllerGetConfigurationRequest) Distinct(distinct bool) ApiApiControllersManagerControllerGetConfigurationRequest {
	r.distinct = &distinct
	return r
}

func (r ApiApiControllersManagerControllerGetConfigurationRequest) Execute() (*ApiControllersClusterControllerGetConfigurationNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetConfigurationExecute(r)
}

/*
ApiControllersManagerControllerGetConfiguration Get configuration

Return wazuh configuration used. The 'section' and 'field' parameters will be ignored if 'raw' parameter is provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetConfigurationRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetConfiguration(ctx context.Context) ApiApiControllersManagerControllerGetConfigurationRequest {
	return ApiApiControllersManagerControllerGetConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetConfigurationNode200Response
func (a *ManagerAPIService) ApiControllersManagerControllerGetConfigurationExecute(r ApiApiControllersManagerControllerGetConfigurationRequest) (*ApiControllersClusterControllerGetConfigurationNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetConfigurationNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.raw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "raw", r.raw, "form", "")
	}
	if r.section != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "section", r.section, "form", "")
	}
	if r.field != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field", r.field, "form", "")
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "form", "")
	} else {
		var defaultValue bool = false
		r.distinct = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetDaemonStatsRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
	daemonsList *[]string
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetDaemonStatsRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetDaemonStatsRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetDaemonStatsRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetDaemonStatsRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// List of daemon names (separated by comma), all daemons selected by default if not specified
func (r ApiApiControllersManagerControllerGetDaemonStatsRequest) DaemonsList(daemonsList []string) ApiApiControllersManagerControllerGetDaemonStatsRequest {
	r.daemonsList = &daemonsList
	return r
}

func (r ApiApiControllersManagerControllerGetDaemonStatsRequest) Execute() (*ApiControllersClusterControllerGetDaemonStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetDaemonStatsExecute(r)
}

/*
ApiControllersManagerControllerGetDaemonStats Get Wazuh daemon stats

Return Wazuh statistical information from specified daemons

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetDaemonStatsRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetDaemonStats(ctx context.Context) ApiApiControllersManagerControllerGetDaemonStatsRequest {
	return ApiApiControllersManagerControllerGetDaemonStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetDaemonStatsNode200Response
func (a *ManagerAPIService) ApiControllersManagerControllerGetDaemonStatsExecute(r ApiApiControllersManagerControllerGetDaemonStatsRequest) (*ApiControllersClusterControllerGetDaemonStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetDaemonStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetDaemonStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/daemons/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.daemonsList != nil {
		t := *r.daemonsList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "daemons_list", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "daemons_list", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetInfoRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetInfoRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetInfoRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetInfoRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetInfoRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerGetInfoRequest) Execute() (*ApiControllersClusterControllerGetInfoNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetInfoExecute(r)
}

/*
ApiControllersManagerControllerGetInfo Get information

Return basic information such as version, compilation date, installation path

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetInfoRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetInfo(ctx context.Context) ApiApiControllersManagerControllerGetInfoRequest {
	return ApiApiControllersManagerControllerGetInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetInfoNode200Response
func (a *ManagerAPIService) ApiControllersManagerControllerGetInfoExecute(r ApiApiControllersManagerControllerGetInfoRequest) (*ApiControllersClusterControllerGetInfoNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetInfoNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetLogRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
	offset *int32
	limit *int32
	sort *string
	search *string
	tag *string
	level *string
	q *string
	select_ *[]string
	distinct *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetLogRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetLogRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetLogRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetLogRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// First element to return in the collection
func (r ApiApiControllersManagerControllerGetLogRequest) Offset(offset int32) ApiApiControllersManagerControllerGetLogRequest {
	r.offset = &offset
	return r
}

// Maximum number of lines to return.
func (r ApiApiControllersManagerControllerGetLogRequest) Limit(limit int32) ApiApiControllersManagerControllerGetLogRequest {
	r.limit = &limit
	return r
}

// Sort the collection by a field or fields (separated by comma). Use +/- at the beggining to list in ascending or descending order. Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersManagerControllerGetLogRequest) Sort(sort string) ApiApiControllersManagerControllerGetLogRequest {
	r.sort = &sort
	return r
}

// Look for elements containing the specified string. To obtain a complementary search, use &#39;-&#39; at the beginning
func (r ApiApiControllersManagerControllerGetLogRequest) Search(search string) ApiApiControllersManagerControllerGetLogRequest {
	r.search = &search
	return r
}

// Wazuh component that logged the event
func (r ApiApiControllersManagerControllerGetLogRequest) Tag(tag string) ApiApiControllersManagerControllerGetLogRequest {
	r.tag = &tag
	return r
}

// Filter by log level
func (r ApiApiControllersManagerControllerGetLogRequest) Level(level string) ApiApiControllersManagerControllerGetLogRequest {
	r.level = &level
	return r
}

// Query to filter results by. For example q&#x3D;&amp;quot;status&#x3D;active&amp;quot;
func (r ApiApiControllersManagerControllerGetLogRequest) Q(q string) ApiApiControllersManagerControllerGetLogRequest {
	r.q = &q
	return r
}

// Select which fields to return (separated by comma). Use &#39;.&#39; for nested fields. For example, &#39;{field1: field2}&#39; may be selected with &#39;field1.field2&#39;
func (r ApiApiControllersManagerControllerGetLogRequest) Select_(select_ []string) ApiApiControllersManagerControllerGetLogRequest {
	r.select_ = &select_
	return r
}

// Look for distinct values.
func (r ApiApiControllersManagerControllerGetLogRequest) Distinct(distinct bool) ApiApiControllersManagerControllerGetLogRequest {
	r.distinct = &distinct
	return r
}

func (r ApiApiControllersManagerControllerGetLogRequest) Execute() (*ApiControllersClusterControllerGetLogNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetLogExecute(r)
}

/*
ApiControllersManagerControllerGetLog Get logs

Return the last 2000 wazuh log entries

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetLogRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetLog(ctx context.Context) ApiApiControllersManagerControllerGetLogRequest {
	return ApiApiControllersManagerControllerGetLogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetLogNode200Response
func (a *ManagerAPIService) ApiControllersManagerControllerGetLogExecute(r ApiApiControllersManagerControllerGetLogRequest) (*ApiControllersClusterControllerGetLogNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetLogNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "form", "")
	} else {
		var defaultValue bool = false
		r.distinct = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetLogSummaryRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetLogSummaryRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetLogSummaryRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetLogSummaryRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetLogSummaryRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerGetLogSummaryRequest) Execute() (*ApiControllersClusterControllerGetLogSummaryNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetLogSummaryExecute(r)
}

/*
ApiControllersManagerControllerGetLogSummary Get logs summary

Return a summary of the last 2000 wazuh log entries

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetLogSummaryRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetLogSummary(ctx context.Context) ApiApiControllersManagerControllerGetLogSummaryRequest {
	return ApiApiControllersManagerControllerGetLogSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetLogSummaryNode200Response
func (a *ManagerAPIService) ApiControllersManagerControllerGetLogSummaryExecute(r ApiApiControllersManagerControllerGetLogSummaryRequest) (*ApiControllersClusterControllerGetLogSummaryNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetLogSummaryNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetLogSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/logs/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetManagerConfigOndemandRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	component string
	configuration string
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetManagerConfigOndemandRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetManagerConfigOndemandRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetManagerConfigOndemandRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetManagerConfigOndemandRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerGetManagerConfigOndemandRequest) Execute() (*ApiResponse, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetManagerConfigOndemandExecute(r)
}

/*
ApiControllersManagerControllerGetManagerConfigOndemand Get active configuration

Return the requested active configuration in JSON format

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param component Selected agent's component
 @param configuration <p>Selected agent's configuration to read. The configuration to read depends on the selected component. The following table shows all available combinations of component and configuration values:</p> <table class=\"table table-striped table-bordered\"> <thead> <tr> <th>Component</th> <th>Configuration</th> <th>Tag</th> </tr> </thead> <tbody> <tr> <td>agent</td> <td>client</td> <td><code>&lt;client&gt;</code></td> </tr> <tr> <td>agent</td> <td>buffer</td> <td><code>&lt;client_buffer&gt;</code></td> </tr> <tr> <td>agent</td> <td>labels</td> <td><code>&lt;labels&gt;</code></td> </tr> <tr> <td>agent</td> <td>internal</td> <td><code>&lt;agent&gt;</code>, <code>&lt;monitord&gt;</code>, <code>&lt;remoted&gt;</code></td> </tr> <tr> <td>agent</td> <td>anti_tampering</td> <td><code>&lt;anti_tampering&gt;</code></td> </tr> <tr> <td>agentless</td> <td>agentless</td> <td><code>&lt;agentless&gt;</code></td> </tr> <tr> <td>analysis</td> <td>global</td> <td><code>&lt;global&gt;</code></td> </tr> <tr> <td>analysis</td> <td>active_response</td> <td><code>&lt;active-response&gt;</code></td> </tr> <tr> <td>analysis</td> <td>alerts</td> <td><code>&lt;alerts&gt;</code></td> </tr> <tr> <td>analysis</td> <td>command</td> <td><code>&lt;command&gt;</code></td> </tr> <tr> <td>analysis</td> <td>rules</td> <td><code>&lt;rule&gt;</code></td> </tr> <tr> <td>analysis</td> <td>decoders</td> <td><code>&lt;decoder&gt;</code></td> </tr> <tr> <td>analysis</td> <td>internal</td> <td><code>&lt;analysisd&gt;</code></td> </tr> <tr> <td>analysis</td> <td>rule_test</td> <td><code>&lt;rule_test&gt;</code></td> </tr> <tr> <td>auth</td> <td>auth</td> <td><code>&lt;auth&gt;</code></td> </tr> <tr> <td>com</td> <td>active-response</td> <td><code>&lt;active-response&gt;</code></td> </tr> <tr> <td>com</td> <td>logging</td> <td><code>&lt;logging&gt;</code></td> </tr> <tr> <td>com</td> <td>internal</td> <td><code>&lt;execd&gt;</code></td> </tr> <tr> <td>com</td> <td>cluster</td> <td><code>&lt;cluster&gt;</code></td> </tr> <tr> <td>csyslog</td> <td>csyslog</td> <td><code>&lt;csyslog_output&gt;</code></td> </tr> <tr> <td>integrator</td> <td>integration</td> <td><code>&lt;integration&gt;</code></td> </tr> <tr> <td>logcollector</td> <td>localfile</td> <td><code>&lt;localfile&gt;</code></td> </tr> <tr> <td>logcollector</td> <td>socket</td> <td><code>&lt;socket&gt;</code></td> </tr> <tr> <td>logcollector</td> <td>internal</td> <td><code>&lt;logcollector&gt;</code></td> </tr> <tr> <td>mail</td> <td>global</td> <td><code>&lt;global&gt;&lt;email...&gt;</code></td> </tr> <tr> <td>mail</td> <td>alerts</td> <td><code>&lt;email_alerts&gt;</code></td> </tr> <tr> <td>mail</td> <td>internal</td> <td><code>&lt;maild&gt;</code></td> </tr> <tr> <td>monitor</td> <td>global</td> <td><code>&lt;global&gt;</code></td> </tr> <tr> <td>monitor</td> <td>internal</td> <td><code>&lt;monitord&gt;</code></td> </tr> <tr> <td>monitor</td> <td>reports</td> <td><code>&lt;reports&gt;</code></td> </tr> <tr> <td>request</td> <td>global</td> <td><code>&lt;global&gt;</code></td> </tr> <tr> <td>request</td> <td>remote</td> <td><code>&lt;remote&gt;</code></td> </tr> <tr> <td>request</td> <td>internal</td> <td><code>&lt;remoted&gt;</code></td> </tr> <tr> <td>syscheck</td> <td>syscheck</td> <td><code>&lt;syscheck&gt;</code></td> </tr> <tr> <td>syscheck</td> <td>rootcheck</td> <td><code>&lt;rootcheck&gt;</code></td> </tr> <tr> <td>syscheck</td> <td>internal</td> <td><code>&lt;syscheck&gt;</code>, <code>&lt;rootcheck&gt;</code></td> </tr> <tr> <td>wazuh-db</td> <td>internal</td> <td><code>&lt;wazuh_db&gt;</code></td> </tr> <tr> <td>wazuh-db</td> <td>wdb</td> <td><code>&lt;wdb&gt;</code></td> </tr> <tr> <td>wmodules</td> <td>wmodules</td> <td><code>&lt;wodle&gt;</code></td> </tr> </tbody> </table> 
 @return ApiApiControllersManagerControllerGetManagerConfigOndemandRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetManagerConfigOndemand(ctx context.Context, component string, configuration string) ApiApiControllersManagerControllerGetManagerConfigOndemandRequest {
	return ApiApiControllersManagerControllerGetManagerConfigOndemandRequest{
		ApiService: a,
		ctx: ctx,
		component: component,
		configuration: configuration,
	}
}

// Execute executes the request
//  @return ApiResponse
func (a *ManagerAPIService) ApiControllersManagerControllerGetManagerConfigOndemandExecute(r ApiApiControllersManagerControllerGetManagerConfigOndemandRequest) (*ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetManagerConfigOndemand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/configuration/{component}/{configuration}"
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterValueToString(r.component, "component")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configuration"+"}", url.PathEscape(parameterValueToString(r.configuration, "configuration")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetStatsRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
	date *string
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetStatsRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetStatsRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetStatsRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetStatsRequest {
	r.waitForComplete = &waitForComplete
	return r
}

// Date to obtain statistical information from. Format YYYY-MM-DD
func (r ApiApiControllersManagerControllerGetStatsRequest) Date(date string) ApiApiControllersManagerControllerGetStatsRequest {
	r.date = &date
	return r
}

func (r ApiApiControllersManagerControllerGetStatsRequest) Execute() (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetStatsExecute(r)
}

/*
ApiControllersManagerControllerGetStats Get stats

Return Wazuh statistical information for the current or specified date

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetStatsRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetStats(ctx context.Context) ApiApiControllersManagerControllerGetStatsRequest {
	return ApiApiControllersManagerControllerGetStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatsNode200Response
func (a *ManagerAPIService) ApiControllersManagerControllerGetStatsExecute(r ApiApiControllersManagerControllerGetStatsRequest) (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetStatsAnalysisdRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetStatsAnalysisdRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetStatsAnalysisdRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetStatsAnalysisdRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetStatsAnalysisdRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerGetStatsAnalysisdRequest) Execute() (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetStatsAnalysisdExecute(r)
}

/*
ApiControllersManagerControllerGetStatsAnalysisd Get stats analysisd

Return Wazuh analysisd statistical information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetStatsAnalysisdRequest

Deprecated
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetStatsAnalysisd(ctx context.Context) ApiApiControllersManagerControllerGetStatsAnalysisdRequest {
	return ApiApiControllersManagerControllerGetStatsAnalysisdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatsNode200Response
// Deprecated
func (a *ManagerAPIService) ApiControllersManagerControllerGetStatsAnalysisdExecute(r ApiApiControllersManagerControllerGetStatsAnalysisdRequest) (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetStatsAnalysisd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/stats/analysisd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetStatsHourlyRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetStatsHourlyRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetStatsHourlyRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetStatsHourlyRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetStatsHourlyRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerGetStatsHourlyRequest) Execute() (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetStatsHourlyExecute(r)
}

/*
ApiControllersManagerControllerGetStatsHourly Get stats hour

Return Wazuh statistical information per hour. Each number in the averages field represents the average of alerts per hour

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetStatsHourlyRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetStatsHourly(ctx context.Context) ApiApiControllersManagerControllerGetStatsHourlyRequest {
	return ApiApiControllersManagerControllerGetStatsHourlyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatsNode200Response
func (a *ManagerAPIService) ApiControllersManagerControllerGetStatsHourlyExecute(r ApiApiControllersManagerControllerGetStatsHourlyRequest) (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetStatsHourly")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/stats/hourly"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetStatsRemotedRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetStatsRemotedRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetStatsRemotedRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetStatsRemotedRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetStatsRemotedRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerGetStatsRemotedRequest) Execute() (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetStatsRemotedExecute(r)
}

/*
ApiControllersManagerControllerGetStatsRemoted Get stats remoted

Return Wazuh remoted statistical information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetStatsRemotedRequest

Deprecated
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetStatsRemoted(ctx context.Context) ApiApiControllersManagerControllerGetStatsRemotedRequest {
	return ApiApiControllersManagerControllerGetStatsRemotedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatsNode200Response
// Deprecated
func (a *ManagerAPIService) ApiControllersManagerControllerGetStatsRemotedExecute(r ApiApiControllersManagerControllerGetStatsRemotedRequest) (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetStatsRemoted")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/stats/remoted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetStatsWeeklyRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetStatsWeeklyRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetStatsWeeklyRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetStatsWeeklyRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetStatsWeeklyRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerGetStatsWeeklyRequest) Execute() (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetStatsWeeklyExecute(r)
}

/*
ApiControllersManagerControllerGetStatsWeekly Get stats week

Return Wazuh statistical information per week. Each number in the averages field represents the average of alerts per hour for that specific day

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetStatsWeeklyRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetStatsWeekly(ctx context.Context) ApiApiControllersManagerControllerGetStatsWeeklyRequest {
	return ApiApiControllersManagerControllerGetStatsWeeklyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatsNode200Response
func (a *ManagerAPIService) ApiControllersManagerControllerGetStatsWeeklyExecute(r ApiApiControllersManagerControllerGetStatsWeeklyRequest) (*ApiControllersClusterControllerGetStatsNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatsNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetStatsWeekly")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/stats/weekly"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerGetStatusRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerGetStatusRequest) Pretty(pretty bool) ApiApiControllersManagerControllerGetStatusRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerGetStatusRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerGetStatusRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerGetStatusRequest) Execute() (*ApiControllersClusterControllerGetStatusNode200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerGetStatusExecute(r)
}

/*
ApiControllersManagerControllerGetStatus Get status

Return the status of all Wazuh daemons

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerGetStatusRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerGetStatus(ctx context.Context) ApiApiControllersManagerControllerGetStatusRequest {
	return ApiApiControllersManagerControllerGetStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerGetStatusNode200Response
func (a *ManagerAPIService) ApiControllersManagerControllerGetStatusExecute(r ApiApiControllersManagerControllerGetStatusRequest) (*ApiControllersClusterControllerGetStatusNode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerGetStatusNode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerGetStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerPutRestartRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	pretty *bool
	waitForComplete *bool
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerPutRestartRequest) Pretty(pretty bool) ApiApiControllersManagerControllerPutRestartRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerPutRestartRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerPutRestartRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerPutRestartRequest) Execute() (*ApiResponse, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerPutRestartExecute(r)
}

/*
ApiControllersManagerControllerPutRestart Restart manager

Restart the wazuh manager

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerPutRestartRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerPutRestart(ctx context.Context) ApiApiControllersManagerControllerPutRestartRequest {
	return ApiApiControllersManagerControllerPutRestartRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiResponse
func (a *ManagerAPIService) ApiControllersManagerControllerPutRestartExecute(r ApiApiControllersManagerControllerPutRestartRequest) (*ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerPutRestart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/restart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiControllersManagerControllerUpdateConfigurationRequest struct {
	ctx context.Context
	ApiService *ManagerAPIService
	body *os.File
	pretty *bool
	waitForComplete *bool
}

// Content of the ossec.conf to be uploaded
func (r ApiApiControllersManagerControllerUpdateConfigurationRequest) Body(body *os.File) ApiApiControllersManagerControllerUpdateConfigurationRequest {
	r.body = body
	return r
}

// Show results in human-readable format
func (r ApiApiControllersManagerControllerUpdateConfigurationRequest) Pretty(pretty bool) ApiApiControllersManagerControllerUpdateConfigurationRequest {
	r.pretty = &pretty
	return r
}

// Disable timeout response
func (r ApiApiControllersManagerControllerUpdateConfigurationRequest) WaitForComplete(waitForComplete bool) ApiApiControllersManagerControllerUpdateConfigurationRequest {
	r.waitForComplete = &waitForComplete
	return r
}

func (r ApiApiControllersManagerControllerUpdateConfigurationRequest) Execute() (*ApiControllersClusterControllerUpdateConfiguration200Response, *http.Response, error) {
	return r.ApiService.ApiControllersManagerControllerUpdateConfigurationExecute(r)
}

/*
ApiControllersManagerControllerUpdateConfiguration Update Wazuh configuration

Replace Wazuh configuration with the data contained in the API request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiControllersManagerControllerUpdateConfigurationRequest
*/
func (a *ManagerAPIService) ApiControllersManagerControllerUpdateConfiguration(ctx context.Context) ApiApiControllersManagerControllerUpdateConfigurationRequest {
	return ApiApiControllersManagerControllerUpdateConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiControllersClusterControllerUpdateConfiguration200Response
func (a *ManagerAPIService) ApiControllersManagerControllerUpdateConfigurationExecute(r ApiApiControllersManagerControllerUpdateConfigurationRequest) (*ApiControllersClusterControllerUpdateConfiguration200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiControllersClusterControllerUpdateConfiguration200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagerAPIService.ApiControllersManagerControllerUpdateConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "form", "")
	} else {
		var defaultValue bool = false
		r.pretty = &defaultValue
	}
	if r.waitForComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait_for_complete", r.waitForComplete, "form", "")
	} else {
		var defaultValue bool = false
		r.waitForComplete = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
